<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>我的2023</title>
      <link href="/2023/12/31/%E6%88%91%E7%9A%842023/"/>
      <url>/2023/12/31/%E6%88%91%E7%9A%842023/</url>
      
        <content type="html"><![CDATA[<h3 id="一月"><a href="#一月" class="headerlink" title="一月"></a>一月</h3><p>p1 烫了个满意的发型<br>p2 买了个小金戒指<br>p3 新年第一顿椰子鸡<br>p4-p12随便逛一逛<br>p13-14 公司发的年货，还不错欸<br>p15-p17 不停的干饭</p><div style="display:flex">  <img src='https://blog-picture.pages.dev/img/2023/01.jpg' width="95%">  <img src='https://blog-picture.pages.dev/img/2023/02.jpg' width="95%">  <img src='https://blog-picture.pages.dev/img/2023/03.jpg' width="95%"></div><div style="display:flex">  <img src='https://blog-picture.pages.dev/img/2023/04.jpg' width="95%">  <img src='https://blog-picture.pages.dev/img/2023/05.jpg' width="95%">  <img src='https://blog-picture.pages.dev/img/2023/06.jpg' width="95%"></div><div style="display:flex">  <img src='https://blog-picture.pages.dev/img/2023/07.jpg' width="95%">  <img src='https://blog-picture.pages.dev/img/2023/12.jpg' width="95%">  <img src='https://blog-picture.pages.dev/img/2023/08.jpg' width="95%"></div><div style="display:flex">  <img src='https://blog-picture.pages.dev/img/2023/09.jpg' width="95%">  <img src='https://blog-picture.pages.dev/img/2023/10.jpg' width="95%">  <img src='https://blog-picture.pages.dev/img/2023/11.jpg' width="95%"></div><div style="display:flex">  <img src='https://blog-picture.pages.dev/img/2023/13.jpg' width="95%">  <img src='https://blog-picture.pages.dev/img/2023/14.jpg' width="95%">  <img src='https://blog-picture.pages.dev/img/2023/15.jpg' width="95%"></div><div style="display:flex">  <img src='https://blog-picture.pages.dev/img/2023/16.jpg' width="95%">  <img src='https://blog-picture.pages.dev/img/2023/17.jpg' width="95%"></div>]]></content>
      
      
      <categories>
          
          <category> 小王的碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2023 </tag>
            
            <tag> 日常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二月的日常碎片</title>
      <link href="/2023/02/28/%E4%BA%8C%E6%9C%88%E7%9A%84%E6%97%A5%E5%B8%B8%E7%A2%8E%E7%89%87/"/>
      <url>/2023/02/28/%E4%BA%8C%E6%9C%88%E7%9A%84%E6%97%A5%E5%B8%B8%E7%A2%8E%E7%89%87/</url>
      
        <content type="html"><![CDATA[<h2 id="一大波图片来袭"><a href="#一大波图片来袭" class="headerlink" title="一大波图片来袭"></a>一大波图片来袭</h2><h3 id="在公司的最后一个月"><a href="#在公司的最后一个月" class="headerlink" title="在公司的最后一个月"></a>在公司的最后一个月</h3><p>靠窗的位置风景不错，还能晒到太阳，最后的日落，相机拍不出他的美</p><div style="display:flex">  <img src='https://blog-picture.pages.dev/img/February/20230211.jpg' width="95%" height="85%">  <img src='https://blog-picture.pages.dev/img/February/20230212.jpg' width="95%">  <img src='https://blog-picture.pages.dev/img/February/20230214.jpg' width="95%"></div><h3 id="一些吃的"><a href="#一些吃的" class="headerlink" title="一些吃的"></a>一些吃的</h3><p>每周一次的出去改善伙食</p><div style="display:flex">  <img src='https://blog-picture.pages.dev/img/February/20230215.jpg' width="95%">  <img src='https://blog-picture.pages.dev/img/February/20230216.jpg' width="95%">  <img src='https://blog-picture.pages.dev/img/February/20230220.jpg' width="95%"></div><div style="display:flex">  <img src='https://blog-picture.pages.dev/img/February/20230218.jpg' width="95%">  <img src='https://blog-picture.pages.dev/img/February/20230219.jpg' width="95%" height="85%">  <img src='https://blog-picture.pages.dev/img/February/20230217.jpg' width="95%"></div><div style="display:flex">  <img src='https://blog-picture.pages.dev/img/February/20230222.jpg' width="95%">  <img src='https://blog-picture.pages.dev/img/February/20230223.jpg' width="95%">  <img src='https://blog-picture.pages.dev/img/February/20230224.jpg' width="95%"></div><div style="display:flex">  <img src='https://blog-picture.pages.dev/img/February/20230225.jpg' width="95%">  <img src='https://blog-picture.pages.dev/img/February/20230226.jpg' width="95%">  <img src='https://blog-picture.pages.dev/img/February/20230227.jpg' width="95%"></div><h3 id="一些玩的"><a href="#一些玩的" class="headerlink" title="一些玩的"></a>一些玩的</h3><p>橘子洲人超多的。娃娃好好看，可是抓不到。期望有一天能挂出大奖。最后买了好利来，回家啦。</p><div style="display:flex">  <img src='https://blog-picture.pages.dev/img/February/20230229.jpg' width="95%">  <img src='https://blog-picture.pages.dev/img/February/20230230.jpg' width="95%">  <img src='https://blog-picture.pages.dev/img/February/20230231.jpg' width="95%"></div><div style="display:flex">  <img src='https://blog-picture.pages.dev/img/February/20230232.jpg' width="95%">  <img src='https://blog-picture.pages.dev/img/February/20230233.jpg' width="95%">  <img src='https://blog-picture.pages.dev/img/February/20230234.jpg' width="95%"></div><div style="display:flex">  <img src='https://blog-picture.pages.dev/img/February/20230235.jpg' width="95%">  <img src='https://blog-picture.pages.dev/img/February/20230236.jpg' width="95%">  <img src='https://blog-picture.pages.dev/img/February/20230237.jpg' width="95%"></div><h3 id="游戏"><a href="#游戏" class="headerlink" title="游戏"></a>游戏</h3><p>纪念一下二月的一个五杀</p><div style="display:flex">  <img src='https://blog-picture.pages.dev/img/February/20230210.jpg' width="95%"></div><h3 id="一些好看的图片"><a href="#一些好看的图片" class="headerlink" title="一些好看的图片"></a>一些好看的图片</h3><p>最后分享一些好看的图片把</p><div style="display:flex">  <img src='https://blog-picture.pages.dev/img/February/20230201.jpg' width="95%" height="85%">  <img src='https://blog-picture.pages.dev/img/February/20230202.jpg' width="95%">  <img src='https://blog-picture.pages.dev/img/February/20230203.jpg' width="95%" height="85%"></div><div style="display:flex">  <img src='https://blog-picture.pages.dev/img/February/20230208.jpg' width="95%" height="83%">  <img src='https://blog-picture.pages.dev/img/February/20230209.jpg' width="95%"></div><div style="display:flex">  <img src='https://blog-picture.pages.dev/img/February/20230204.jpg' width="95%" height="63%">  <img src='https://blog-picture.pages.dev/img/February/20230205.jpg' width="95%">  <img src='https://blog-picture.pages.dev/img/February/20230206.jpg' width="95%" height="63%">  <img src='https://blog-picture.pages.dev/img/February/20230207.jpg' width="95%" height="63%"></div>]]></content>
      
      
      <categories>
          
          <category> 小王的碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日常 </tag>
            
            <tag> 二月 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue笔记</title>
      <link href="/2023/02/14/vue%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/02/14/vue%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Vue双向数据绑定的原理"><a href="#Vue双向数据绑定的原理" class="headerlink" title="Vue双向数据绑定的原理"></a>Vue双向数据绑定的原理</h1><p>Vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。主要分为以下几个步骤：</p><ol><li>需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上setter和getter，当给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化</li><li>compile解析模版指令，将模版中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图</li><li>Watcher订阅者是Observer和Compile之间通信的桥梁，在自身实例化时往属性订阅器里面添加自己，自身必须有一个update()方法，待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调。</li><li>MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据model变更的双向绑定效果。</li></ol><h1 id="Computed、Watch、Methods的区别"><a href="#Computed、Watch、Methods的区别" class="headerlink" title="Computed、Watch、Methods的区别"></a>Computed、Watch、Methods的区别</h1><ol><li>Computed</li></ol><ul><li>支持缓存，只有依赖的数据发生了变化，才会重新计算</li><li>不支持异步，当Computed中有异步操作时，无法监听数据的变化</li><li>computed的值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，也就是基于data声明过，或者父组件传递过来的props中的数据进行计算的。</li><li>如果一个属性是由其他属性计算而来的，这个属性依赖其他的属性，一般会使用computed</li><li>如果computed属性的属性值是函数，那么默认使用get方法，函数的返回值就是属性的属性值；在computed中，属性有一个get方法和一个set方法，当数据发生变化时，会调用set方法。</li></ul><ol><li>Watch</li></ol><ul><li>它不支持缓存，数据变化时，它就会触发相应的操作</li><li>支持异步监听</li><li>监听的函数接收两个参数，第一个参数是最新的值，第二个是变化之前的值<br>当一个属性发生变化时，就需要执行相应的操作</li><li>监听数据必须是data中声明的或者父组件传递过来的props中的数据，当发生变化时，会触发其他操作，函数有两个的参数：<br>immediate：组件加载立即触发回调函数<br>deep：深度监听，发现数据内部的变化，在复杂数据类型中使用，例如数组中的对象发生变化。</li></ul><ol><li>methods<br>调用总会执行该函数</li></ol><h1 id="常见的事件修饰符及其作用"><a href="#常见的事件修饰符及其作用" class="headerlink" title="常见的事件修饰符及其作用"></a>常见的事件修饰符及其作用</h1><ul><li><code>.stop</code>：等同于JavaScript中的<code>event.stopPropagation()</code>，防止事件冒泡；</li><li><code>.prevent</code> ：等同于JavaScript中的<code>event.preventDefault()</code>，防止执行预设的行为（如果事件可取消，则取消该事件，而不停止事件的进一步传播）；</li><li><code>.capture</code>：与事件冒泡的方向相反，事件捕获由外到内；</li><li><code>.self</code>：只会触发自己范围内的事件，不包含子元素；</li><li><code>.once</code>：只会触发一次</li></ul><h1 id="v-model是如何实现的"><a href="#v-model是如何实现的" class="headerlink" title="v-model是如何实现的"></a>v-model是如何实现的</h1><ol><li>作用在表单元素上，动态绑定了input的value指向了message变量，并且在触发input事件的时候去动态把message设置为目标值<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-model=<span class="string">&quot;sth&quot;</span> /&gt;</span><br><span class="line"><span class="comment">//  等同于</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">input</span> </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">v-bind:value</span>=<span class="string">&quot;message&quot;</span> </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">v-on:input</span>=<span class="string">&quot;message=$event.target.value&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">/&gt;</span></span></span><br></pre></td></tr></table></figure></li><li>作用在组件上，在自定义组件中，v-model默认会利用名为value的prop和名为input的事件。本质是一个父子组件通信的语法糖，通过prop和$emit实现。因此父组件 v-model 语法糖本质上可以修改为：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;child :value=<span class="string">&quot;message&quot;</span> @input=<span class="string">&quot;function(e)&#123;message = e&#125;&quot;</span>&gt;&lt;/child&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义组件</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">my-input</span> <span class="attr">v-model</span>=<span class="string">&quot;searchValue&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">my-input</span>&gt;</span></span></span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">my-input</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">v-bind:value</span>=<span class="string">&quot;searchValue&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">v-on:input</span>=<span class="string">&quot;searchValue = $event&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">&gt;</span><span class="tag">&lt;/<span class="name">my-input</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li></ol><h1 id="data为什么是一个函数而不是对象"><a href="#data为什么是一个函数而不是对象" class="headerlink" title="data为什么是一个函数而不是对象"></a>data为什么是一个函数而不是对象</h1><p>JavaScript中的对象是引用类型的数据，当多个实例引用同一个对象时，只要一个实例对这个对象进行操作，其他实例中的数据也会发生变化。而在Vue中，更多的是想要复用组件，那就需要每个组件都有自己的数据，这样组件之间才不会相互干扰。<br>所以组件的数据不能写成对象的形式，而是要写成函数的形式。数据以函数返回值的形式定义，这样当每次复用组件的时候，就会返回一个新的data，也就是说每个组件都有自己的私有数据空间，它们各自维护自己的数据，不会干扰其他组件的正常运行。<br>根实例对象data可以是对象也可以是函数（根实例是单例），不会产生数据污染情况<br>组件实例对象data必须为函数，目的是为了防止多个组件实例对象之间共用一个data，产生数据污染。采用函数的形式</p><h1 id="nextTick-使用场景"><a href="#nextTick-使用场景" class="headerlink" title="nextTick()使用场景"></a>nextTick()使用场景</h1><ul><li>在数据变化后执行的某个操作，而这个操作需要使用随数据变化而变化的DOM结构的时候，这个操作就需要方法在nextTick()的回调函数中。</li><li>在vue生命周期中，如果在created()钩子进行DOM操作，也一定要放在nextTick()的回调函数中。因为在created()钩子函数中，页面的DOM还未渲染，这时候也没办法操作DOM。</li></ul><h1 id="assets和static的区别"><a href="#assets和static的区别" class="headerlink" title="assets和static的区别"></a>assets和static的区别</h1><ul><li>相同点：<code>assets</code>和<code>static</code>两个都是存放静态资源文件。项目中所需要的资源文件图片，字体图标，样式文件等都可以放在这两个文件下</li><li>不同点：<code>assets</code>中存放的静态资源文件在项目打包时，也就是运行<code>npm run build</code>时会将<code>assets</code>中放置的静态资源文件进行打包上传，所谓打包简单点可以理解为压缩体积，代码格式化。而压缩后的静态资源文件最终也都会放置在 <code>static</code> 文件中跟着 <code>index.html</code> 一同上传至服务器。<code>static</code> 中放置的静态资源文件就不会要走打包压缩格式化等流程，而是直接进入打包好的目录，直接上传至服务器。因为避免了压缩直接进行上传，在打包时会提高一定的效率，但是 <code>static</code> 中的资源文件由于没有进行压缩等操作，所以文件的体积也就相对于 <code>assets</code> 中打包后的文件提交较大点。在服务器中就会占据更大的空间</li><li>建议：将项目中 <code>template</code>需要的样式文件js文件等都可以放置在 <code>assets</code> 中，走打包这一流程。减少体积。而项目中引入的第三方的资源文件如<code>iconfoont.css</code> 等文件可以放置在 <code>static</code>中，因为这些引入的第三方文件已经经过处理，不再需要处理，直接上传。</li></ul><h1 id="delete和Vue-delete删除数组的区别"><a href="#delete和Vue-delete删除数组的区别" class="headerlink" title="delete和Vue.delete删除数组的区别"></a>delete和Vue.delete删除数组的区别</h1><ul><li><code>delete</code>只是被删除元素变成了<code>empty/undefined</code>其他的元素的键值还是不变</li><li><code>Vue.delete</code>直接删除了数组，改变了数组的键值</li></ul><h1 id="vue如何监听对象或者数组某个属性的变化"><a href="#vue如何监听对象或者数组某个属性的变化" class="headerlink" title="vue如何监听对象或者数组某个属性的变化"></a>vue如何监听对象或者数组某个属性的变化</h1><p>当在项目中直接设置数组的某一项的值，或者直接设置对象的某个属性值，这个时候，你会发现页面并没有更新。这是因为Object.defineProperty()限制，监听不到变化。<br>解决方式：</p><ul><li>this.$set(你要改变的数组/对象，你要改变的位置/key，你要改成什么value)<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.$set(<span class="variable language_">this</span>.<span class="property">arr</span>, <span class="number">0</span>, <span class="string">&quot;OBKoro1&quot;</span>); <span class="comment">// 改变数组this.$set(this.obj, &quot;c&quot;, &quot;OBKoro1&quot;); // 改变对象</span></span><br></pre></td></tr></table></figure></li><li>调用以下几个数组的方法<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">splice</span>()、 <span class="title function_">push</span>()、<span class="title function_">pop</span>()、<span class="title function_">shift</span>()、<span class="title function_">unshift</span>()、<span class="title function_">sort</span>()、<span class="title function_">reverse</span>()</span><br></pre></td></tr></table></figure>vue源码里缓存了array的原型链，然后重写了这几个方法，触发这几个方法的时候会observer数据，意思是使用这些方法不用再进行额外的操作，视图自动进行更新。推荐使用splice方法会比较好自定义,因为splice可以在数组的任何位置进行删除/添加操作<br><code>vm.$set</code> 的实现原理是：</li><li>如果目标是数组，直接使用数组的<code>splice</code>方法触发响应式</li><li>如果目标是对象，会先判断属性是否存在、对象是否是响应式，最终如果要对属性进行响应式处理，则是通过调用<code>defineReactive</code> 方法进行响应式处理（ <code>defineReactive</code> 方法就是 Vue 在初始化对象时，给对象属性采用 <code>Object.defineProperty</code> 动态添加 <code>getter</code> 和 <code>setter</code> 的功能所调用的方法）</li></ul><h1 id="对SSR的理解"><a href="#对SSR的理解" class="headerlink" title="对SSR的理解"></a>对SSR的理解</h1><p>SSR也就是服务端渲染，也就是将Vue在客户端把标签渲染成HTML的工作放在服务端完成，然后再把HTML直接返回给客户端<br>优点：</p><ul><li>更好的SEO</li><li>首屏加载速度更快</li></ul><p>缺点：</p><ul><li>开发条件会受到限制，服务器端渲染只支持beforeCreate和created两个钩子；</li><li>当需要一些外部扩展库时需要特殊处理，服务端渲染应用程序也需要处于Node.js的运行环境；</li><li>更多的服务端负载。</li></ul><h1 id="Vue性能优化"><a href="#Vue性能优化" class="headerlink" title="Vue性能优化"></a>Vue性能优化</h1><ol><li>编码阶段</li></ol><ul><li>尽量减少data中的数据，data中的数据都会增加getter和setter，会收集对应的watcher</li><li>v-if和v-for不能连用</li><li>key保证唯一</li><li>使用路由懒加载、异步组件</li><li>防抖、节流</li><li>第三方模块按需导入</li><li>长列表滚动到可视区域动态加载</li><li>图片懒加载</li></ul><ol><li>SEO优化</li></ol><ul><li>预渲染</li><li>服务端渲染SSR</li></ul><ol><li>打包优化</li></ol><ul><li>压缩代码</li><li>使用cdn加载第三方模块</li><li>多线程打包happypack</li><li>splitChunks抽离公共文件</li><li>sourceMap优化</li></ul><ol><li>用户体验</li></ol><ul><li>骨架屏</li><li>PWA</li><li>还可以使用缓存(客户端缓存、服务端缓存)优化、服务端开启gzip压缩等。</li></ul><h1 id="vue初始化页面闪动问题"><a href="#vue初始化页面闪动问题" class="headerlink" title="vue初始化页面闪动问题"></a>vue初始化页面闪动问题</h1><p>使用vue开发时，在vue初始化之前，由于div是不归vue管的，所以我们写的代码在还没有解析的情况下会容易出现花屏现象，看到类似于的字样，虽然一般情况下这个时间很短暂，但是还是有必要让解决这个问题的。<br>在css里加上以下代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[v-cloak] &#123;    <span class="attr">display</span>: none;&#125;</span><br></pre></td></tr></table></figure><br>如果没有彻底解决问题，则在根元素加上<code>style=&quot;display: none;&quot; :style=&quot;&#123;display: &#39;block&#39;&#125;&quot;</code></p><h1 id="Vue的生命周期"><a href="#Vue的生命周期" class="headerlink" title="Vue的生命周期"></a>Vue的生命周期</h1><ol><li>beforeCreate（创建前）：数据观测和初始化事件还未开始，此时 data 的响应式追踪、event/watcher 都还没有被设置，也就是说不能访问到data、computed、watch、methods上的方法和数据。</li><li>created（创建后）：实例创建完成，实例上配置的 options 包括 data、computed、watch、methods 等都配置完成，但是此时渲染得节点还未挂载到 DOM，所以不能访问到 $el 属性。</li><li>beforeMount（挂载前）：在挂载开始之前被调用，相关的render函数首次被调用。实例已完成以下的配置：编译模板，把data里面的数据和模板生成html。此时还没有挂载html到页面上。</li><li>mounted（挂载后）：在el被新创建的 vm.$el 替换，并挂载到实例上去之后调用。实例已完成以下的配置：用上面编译好的html内容替换el属性指向的DOM对象。完成模板中的html渲染到html页面中。此过程中进行ajax交互。</li><li>beforeUpdate（更新前）：响应式数据更新时调用，此时虽然响应式数据更新了，但是对应的真实 DOM 还没有被渲染。</li><li>updated（更新后）：在由于数据更改导致的虚拟DOM重新渲染和打补丁之后调用。此时 DOM 已经根据响应式数据的变化更新了。调用时，组件DOM已经更新，所以可以执行依赖于DOM的操作。然而在大多数情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用。</li><li>beforeDestroy（销毁前）：实例销毁之前调用。这一步，实例仍然完全可用，this 仍能获取到实例。</li><li>destroyed（销毁后）：实例销毁后调用，调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务端渲染期间不被调用。</li></ol><p>（注意：还有<code>keep-alive</code>独有的生命周期，分别为<code>activated</code>和<code>deactivated</code>。用<code>keep-alive</code>包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行<code>deactivated</code>钩子函数，命中缓存渲染后会执行<code>activated</code>钩子函数）</p><h1 id="组件通信"><a href="#组件通信" class="headerlink" title="组件通信"></a>组件通信</h1><ol><li>props / $emit<br>父组件通过props向子组件传递数据，子组件通过$emit和父组件通信</li></ol><ul><li>父组件向子组件传值<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 父组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;father&quot;&gt;</span><br><span class="line">    &lt;son :msg=&quot;msgData&quot; :fn=&quot;myFunction&quot;&gt;&lt;/son&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import son from &quot;./son.vue&quot;;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: father,</span><br><span class="line">  data() &#123;</span><br><span class="line">    msgData: &quot;父组件数据&quot;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    myFunction() &#123;</span><br><span class="line">      console.log(&quot;vue&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    son</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 子组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;son&quot;&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;button @click=&quot;fn&quot;&gt;按钮&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;son&quot;,</span><br><span class="line">  props: [&quot;msg&quot;, &quot;fn&quot;]</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li>子组件向父组件传值<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 父组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;section&quot;&gt;</span><br><span class="line">    &lt;son @getValue=&quot;getValue&quot;&gt;&lt;/son&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import son from &quot;./son.vue&quot;;</span><br><span class="line">export default &#123;</span><br><span class="line">  components: &#123; son &#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      value: &#x27;123&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    getValue(data) &#123;</span><br><span class="line">      this.value = data</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 子组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  mounted()&#123;</span><br><span class="line">    this.$emit(&#x27;getValue&#x27;, this.getValue)</span><br><span class="line">  &#125;,</span><br><span class="line">  methods:&#123;</span><br><span class="line">    getValue(data)&#123;</span><br><span class="line">      // do something</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ul><ol><li>eventBus事件总线（$emit / $on）<br>这种方法通过一个空的Vue实例作为中央事件总线（事件中心），用它来触发事件和监听事件,巧妙而轻量地实现了任何组件间的通信，包括父子、兄弟、跨级。</li><li>依赖注入（provide / inject）<br>这种方式就是Vue中的依赖注入，该方法用于父子组件之间的通信。当然这里所说的父子不一定是真正的父子，也可以是祖孙组件，在层数很深的情况下，可以使用这种方法来进行传值。就不用一层一层的传递了。<br>provide / inject是Vue提供的两个钩子，和data、methods是同级的。并且provide的书写形式和data一样。<br>provide 钩子用来发送数据或方法<br>inject钩子用来接收数据或方法</li><li>ref / $refs<br>这种方式也是实现父子组件之间的通信。<br>ref： 这个属性用在子组件上，它的引用就指向了子组件的实例。可以通过实例来访问组件的数据和方法。</li><li>$parent / $children<br>使用$parent可以让组件访问父组件的实例（访问的是上一级父组件的属性和方法）<br>使用$children可以让组件访问子组件的实例，但是，$children并不能保证顺序，并且访问的数据也不是响应式的。</li><li>$attrs / $listeners</li><li>vuex</li></ol><h1 id="路由懒加载"><a href="#路由懒加载" class="headerlink" title="路由懒加载"></a>路由懒加载</h1><p>非懒加载<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">List</span> <span class="keyword">from</span> <span class="string">&#x27;@/components/list.vue&#x27;</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123;</span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&#x27;/list&#x27;</span>, <span class="attr">component</span>: <span class="title class_">List</span> &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><br>懒加载</p><ol><li>使用箭头函数+import动态加载<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">List</span> = (<span class="params"></span>) =&gt; <span class="keyword">import</span>(<span class="string">&#x27;@/components/list.vue&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123;</span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&#x27;/list&#x27;</span>, <span class="attr">component</span>: <span class="title class_">List</span> &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li>使用箭头函数+require动态加载<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">Router</span>(&#123;</span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="attr">path</span>: <span class="string">&#x27;/list&#x27;</span>,</span><br><span class="line">     <span class="attr">component</span>: <span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">require</span>([<span class="string">&#x27;@/components/list&#x27;</span>], resolve)</span><br><span class="line">   &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li>使用webpack的require.ensure技术，也可以实现按需加载。 这种情况下，多个路由指定相同的chunkName，会合并打包成一个js文件。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// r就是resolve</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">List</span> = r =&gt; <span class="built_in">require</span>.<span class="title function_">ensure</span>([], <span class="function">() =&gt;</span> <span class="title function_">r</span>(<span class="built_in">require</span>(<span class="string">&#x27;@/components/list&#x27;</span>)), <span class="string">&#x27;list&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">Router</span>(&#123;</span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/list&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="title class_">List</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;list&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line"> ]</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure></li></ol><h1 id="路由的hash和history模式的区别"><a href="#路由的hash和history模式的区别" class="headerlink" title="路由的hash和history模式的区别"></a>路由的hash和history模式的区别</h1><p>默认的路由模式是hash模式</p><ol><li>hash模式</li></ol><ul><li>hash模式是开发中默认的模式，它的URL带着一个#，例如：www.abc.com/#/vue，它的hash值就是#/vue。</li><li>特点：hash值会出现在URL里面，但是不会出现在HTTP请求中，对后端完全没有影响。所以改变hash值，不会重新加载页面。这种模式的浏览器支持度很好，低版本的IE浏览器也支持这种模式。hash路由被称为是前端路由，已经成为SPA（单页面应用）的标配。</li><li>原理：hash模式的主要原理就是onhashchange()事件：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">onhashchange</span> = <span class="keyword">function</span>(<span class="params">event</span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">oldURL</span>, event.<span class="property">newURL</span>);</span><br><span class="line">  <span class="keyword">let</span> hash = location.<span class="property">hash</span>.<span class="title function_">slice</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>使用onhashchange()事件的好处就是，在页面的hash值发生变化时，无需向后端发起请求，window就可以监听事件的改变，并按规则加载相应的代码。除此之外，hash值变化对应的URL都会被浏览器记录下来，这样浏览器就能实现页面的前进和后退。虽然是没有请求后端服务器，但是页面的hash值和对应的URL关联起来了。</li></ul><ol><li>history模式</li></ol><ul><li>history模式的URL中没有#，它使用的是传统的路由分发模式，即用户在输入一个URL时，服务器会接收这个请求，并解析这个URL，然后做出相应的逻辑处理。</li><li>特点： 当使用history模式时，URL就像这样：abc.com/user/id。相比hash模式更加好看。但是，history模式需要后台配置支持。如果后台没有正确配置，访问时会返回404。</li><li>API<br>修改历史状态：<code>pushState()</code>和<code>replaceState()</code>方法，这两个方法应用于浏览器的历史记录栈，提供了对历史记录进行修改的功能。只是当他们进行修改时，虽然修改了url，但浏览器不会立即向后端发送请求。如果要做到改变url但又不刷新页面的效果，就需要用上这两个API。<br>切换历史状态： 包括forward()、back()、go()三个方法，对应浏览器的前进，后退，跳转操作。</li></ul><h1 id="如何获取页面的hash变化"><a href="#如何获取页面的hash变化" class="headerlink" title="如何获取页面的hash变化"></a>如何获取页面的hash变化</h1><ol><li>监听$router的变化<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 监听,当路由发生变化的时候执行</span></span><br><span class="line"><span class="attr">watch</span>: &#123;</span><br><span class="line">  <span class="attr">$route</span>: &#123;</span><br><span class="line">    <span class="attr">handler</span>: <span class="keyword">function</span>(<span class="params">val, oldVal</span>)&#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(val);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 深度观察监听</span></span><br><span class="line">    <span class="attr">deep</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><code>window.location.hash</code>读取#值， <code>window.location.hash</code> 的值可读可写，读取来判断状态是否改变，写入时可以在不重载网页的前提下，添加一条历史访问记录。</li></ol><h1 id="route和-router的区别"><a href="#route和-router的区别" class="headerlink" title="$route和$router的区别"></a>$route和$router的区别</h1><ul><li>$route 是“路由信息对象”，包括 path，params，hash，query，fullPath，matched，name 等路由信息参数</li><li>$router 是“路由实例”对象包括了路由的跳转方法，钩子函数等。</li></ul><h1 id="如何定义动态路由？如何获取传过来的动态参数？"><a href="#如何定义动态路由？如何获取传过来的动态参数？" class="headerlink" title="如何定义动态路由？如何获取传过来的动态参数？"></a>如何定义动态路由？如何获取传过来的动态参数？</h1><p>param方式</p><ul><li>配置路由格式：/router/:id</li><li>传递的方式：在path后面跟上对应的值</li><li>传递后形成的路径：/router/123</li></ul><ol><li>路由定义<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在APP.vue中</span></span><br><span class="line">&lt;router-link :to=<span class="string">&quot;&#x27;/user/&#x27;+userId&quot;</span> replace&gt;用户&lt;/router-link&gt;    </span><br><span class="line"></span><br><span class="line"><span class="comment">//在index.js</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">path</span>: <span class="string">&#x27;/user/:userid&#x27;</span>,</span><br><span class="line">  <span class="attr">component</span>: <span class="title class_">User</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>路由跳转<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法1：</span></span><br><span class="line">&lt;router-link :to=<span class="string">&quot;&#123; name: &#x27;users&#x27;, params: &#123; uname: zhang &#125;&#125;&quot;</span>&gt;按钮&lt;/router-link&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法2：</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(&#123;<span class="attr">name</span>:<span class="string">&#x27;users&#x27;</span>,<span class="attr">params</span>:&#123;<span class="attr">uname</span>:zhang&#125;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法3：</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(<span class="string">&#x27;/user/&#x27;</span> + zhang)</span><br></pre></td></tr></table></figure></li><li>参数获取通过 <code>$route.params.userid</code> 获取传递的值</li></ol><p>query方式</p><ul><li>配置路由格式：/router，也就是普通配置</li><li>传递的方式：对象中使用query的key作为传递方式</li><li>传递后形成的路径：/route?id=123</li></ul><ol><li>路由定义<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式1：直接在router-link 标签上以对象的形式</span></span><br><span class="line">&lt;router-link :to=<span class="string">&quot;&#123;path: &#x27;/list&#x27;, query: &#123; name: &#x27;abc&#x27;, age: 18 &#125;&#125;&quot;</span>&gt;信息&lt;/router-link&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式2：写成按钮以点击事件形式</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&#x27;listClick&#x27;</span>&gt;</span>我的<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>    </span><br><span class="line"></span><br><span class="line"><span class="title function_">listClick</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/list&#x27;</span>,</span><br><span class="line">    <span class="attr">query</span>: &#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;abc&#x27;</span>,</span><br><span class="line">      <span class="attr">age</span>: <span class="string">&#x27;18&#x27;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>跳转方法<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法1：</span></span><br><span class="line">&lt;router-link :to=<span class="string">&quot;&#123; name: &#x27;users&#x27;, query: &#123; uname: &#x27;abc&#x27; &#125;&#125;&quot;</span>&gt;按钮&lt;/router-link&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法2：</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;users&#x27;</span>, <span class="attr">query</span>:&#123; <span class="attr">uname</span>: <span class="string">&#x27;abc&#x27;</span> &#125;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法3：</span></span><br><span class="line">&lt;router-link :to=<span class="string">&quot;&#123; path: &#x27;/user&#x27;, query: &#123; uname: &#x27;abc&#x27; &#125;&#125;&quot;</span>&gt;按钮&lt;/router-link&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法4：</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(&#123; <span class="attr">path</span>: <span class="string">&#x27;/user&#x27;</span>, <span class="attr">query</span>:&#123; <span class="attr">uname</span>: <span class="string">&#x27;abc&#x27;</span> &#125;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法5：</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(<span class="string">&#x27;/user?uname=&#x27;</span> + abc)</span><br></pre></td></tr></table></figure></li><li>获取参数<br>通过$route.query获取传递的值</li></ol><h1 id="Vue-Router导航守卫"><a href="#Vue-Router导航守卫" class="headerlink" title="Vue-Router导航守卫"></a>Vue-Router导航守卫</h1><ol><li>全局路由钩子<br>vue-router全局有三个路由钩子</li></ol><ul><li>router.beforeEach 全局前置守卫 进入路由之前<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">router.<span class="title function_">beforeEach</span>(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;  </span><br><span class="line">  <span class="keyword">let</span> ifInfo = <span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$common</span>.<span class="title function_">getSession</span>(<span class="string">&#x27;userData&#x27;</span>) <span class="comment">// 判断是否登录的存储信息</span></span><br><span class="line">  <span class="keyword">if</span> (!ifInfo) &#123; </span><br><span class="line">    <span class="comment">// sessionStorage里没有储存user信息    </span></span><br><span class="line">    <span class="keyword">if</span> (to.<span class="property">path</span> == <span class="string">&#x27;/&#x27;</span>) &#123; </span><br><span class="line">      <span class="comment">//如果是登录页面路径，就直接next()      </span></span><br><span class="line">      <span class="title function_">next</span>();    </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">      <span class="comment">//不然就跳转到登录      </span></span><br><span class="line">      <span class="title class_">Message</span>.<span class="title function_">warning</span>(<span class="string">&quot;请重新登录！&quot;</span>);     </span><br><span class="line">      <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">href</span> = <span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$loginUrl</span>;    </span><br><span class="line">    &#125;  </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;    </span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">next</span>();  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li>router.beforeResolve 全局解析守卫在 beforeRouteEnter 调用之后调用</li><li>router.afterEach 全局后置钩子 进入路由之后<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">router.<span class="title function_">afterEach</span>(<span class="function">(<span class="params">to, <span class="keyword">from</span></span>) =&gt;</span> &#123;  </span><br><span class="line">  <span class="comment">// 跳转之后滚动条回到顶部  </span></span><br><span class="line">  <span class="variable language_">window</span>.<span class="title function_">scrollTo</span>(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><ol><li>单个路由独享钩子<br><code>beforeEnter</code> 如果不想全局配置守卫的话，可以为某些路由单独配置守卫，有三个参数∶ to、from、next<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> [    </span><br><span class="line">  &#123;        </span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>,        </span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;login&#x27;</span>,        </span><br><span class="line">    <span class="attr">component</span>: login,        </span><br><span class="line">    <span class="attr">beforeEnter</span>: <span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;          </span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;即将进入登录页面&#x27;</span>)          </span><br><span class="line">      <span class="title function_">next</span>()        </span><br><span class="line">    &#125;    </span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li><li>组件内钩子<br><code>beforeRouteEnter</code>、<code>beforeRouteUpdate</code>、<code>beforeRouteLeave</code>这三个钩子都有三个参数∶to、from、next</li></ol><ul><li>beforeRouteEnter∶ 进入组件前触发</li><li>beforeRouteUpdate∶ 当前地址改变并且该组件被复用时触发</li><li>beforeRouteLeave∶ 离开组件被调用<br>⚠️注意：beforeRouteEnter组件内还访问不到this，因为该守卫执行前组件实例还没有被创建，需要传一个回调给 next来访问，例如：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">beforeRouteEnter</span>(<span class="params">to, <span class="keyword">from</span>, next</span>) &#123;      </span><br><span class="line">  <span class="title function_">next</span>(<span class="function"><span class="params">target</span> =&gt;</span> &#123;        </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">from</span>.<span class="property">path</span> == <span class="string">&#x27;/list&#x27;</span>) &#123;          </span><br><span class="line">      target.<span class="property">isFromProcess</span> = <span class="literal">true</span>        </span><br><span class="line">    &#125;      </span><br><span class="line">  &#125;)    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="Vue-router跳转和location-href有什么区别"><a href="#Vue-router跳转和location-href有什么区别" class="headerlink" title="Vue-router跳转和location.href有什么区别"></a>Vue-router跳转和location.href有什么区别</h1><ul><li>使用 <code>location.href= /url</code> 来跳转，简单方便，但是刷新了页面；</li><li>使用 <code>history.pushState( /url )</code> ，无刷新页面，静态跳转；</li><li>引进 router ，然后使用 <code>router.push( /url )</code> 来跳转，使用了 diff 算法，实现了按需加载，减少了 dom 的消耗。其实使用 router 跳转和使用 <code>history.pushState()</code> 没什么差别的，因为vue-router就是用了 <code>history.pushState()</code> ，尤其是在history模式下。</li></ul><h1 id="params和query的区别"><a href="#params和query的区别" class="headerlink" title="params和query的区别"></a>params和query的区别</h1><ul><li>query要用path来引入，params要用name来引入（因为 path 会忽略 params 这个属性）<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//query传参，使用path跳转</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line">  <span class="attr">path</span>: <span class="string">&#x27;first&#x27;</span>,</span><br><span class="line">  <span class="attr">query</span>: &#123;</span><br><span class="line">    <span class="attr">queryId</span>: <span class="string">&#x27;123&#x27;</span>,</span><br><span class="line">    <span class="attr">queryName</span>: <span class="string">&#x27;abc&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//query传参接收</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">queryName</span> = <span class="variable language_">this</span>.<span class="property">$route</span>.<span class="property">query</span>.<span class="property">queryName</span>;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">queryId</span> = <span class="variable language_">this</span>.<span class="property">$route</span>.<span class="property">query</span>.<span class="property">queryId</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//params传参 使用name</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line">  <span class="attr">name</span>:<span class="string">&#x27;second&#x27;</span>,</span><br><span class="line">  <span class="attr">params</span>: &#123;</span><br><span class="line">    <span class="attr">id</span>:<span class="string">&#x27;456&#x27;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;def&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//params接收参数</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">id</span> = <span class="variable language_">this</span>.<span class="property">$route</span>.<span class="property">params</span>.<span class="property">id</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">name</span> = <span class="variable language_">this</span>.<span class="property">$route</span>.<span class="property">params</span>.<span class="property">name</span></span><br></pre></td></tr></table></figure></li><li>url地址显示：query更加类似于ajax中get传参，params则类似于post，前者在浏览器地址栏中显示参数，后者则不显示</li><li>query刷新不会丢失query里面的数据 params刷新会丢失 params里面的数据。</li></ul><h1 id="Vuex-和-localStorage-的区别"><a href="#Vuex-和-localStorage-的区别" class="headerlink" title="Vuex 和 localStorage 的区别"></a>Vuex 和 localStorage 的区别</h1><ol><li>区别</li></ol><ul><li>vuex存储在内存中</li><li>localstorage 则以文件的方式存储在本地，只能存储字符串类型的数据，存储对象需要 JSON的stringify和parse方法进行处理。读取内存比读取硬盘速度要快<br>（⚠️注意：对于不变的数据可以用localstorage可以代替vuex，但是当两个组件共用一个数据源（对象或数组）时，如果其中一个组件改变了该数据源，希望另一个组件响应该变化时，localstorage无法做到）</li></ul><ol><li>应用场景</li></ol><ul><li>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。vuex用于组件之间的传值。</li><li>localstorage是本地存储，是将数据存储到浏览器的方法，一般是在跨页面传递数据时使用 。</li><li>Vuex能做到数据的响应式，localstorage不能</li></ul><ol><li>永久性<br>刷新页面时vuex存储的值会丢失，localstorage不会。</li></ol><h1 id="Vuex组件访问State中数据的两种方式"><a href="#Vuex组件访问State中数据的两种方式" class="headerlink" title="Vuex组件访问State中数据的两种方式"></a>Vuex组件访问State中数据的两种方式</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建store数据源，提供唯一公共数据</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title function_">store</span>(&#123;</span><br><span class="line">  <span class="attr">state</span>: &#123;</span><br><span class="line">    <span class="attr">num</span>:<span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ol><li>this.$store.state.全局数据名称<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">$store</span>.<span class="property">state</span>.<span class="property">num</span></span><br></pre></td></tr></table></figure></li><li>导入 mapState 函数 将当前组件需要的全局数据 映射为当前组件的 computed 计算属性<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在需要使用的组件里，从Vuex中按需导入mapState函数</span></span><br><span class="line"><span class="keyword">import</span> &#123; mapState &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//通过刚才导入的mapState函数，将当前组件需要的全局数据，映射为当前组件的computed计算属性。</span></span><br><span class="line"><span class="attr">computed</span>: &#123;</span><br><span class="line">  ...<span class="title function_">mapState</span>([<span class="string">&#x27;num&#x27;</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h1><table>  <tr>    <td>1xx</td>     <td>信息，服务器收到请求，需要请求者继续执行操作</td>   </tr>  <tr>      <td>2xx</td>     <td>成功，操作被成功接收并处理</td>   </tr>  <tr>    <td>3xx</td>     <td>重定向，需要进一步的操作以完成请求</td>   </tr>  <tr>    <td>4xx</td>     <td>客户端错误，请求包含语法错误或无法完成请求</td>   </tr>  <tr>    <td>5xx</td>     <td>服务器错误，服务器在处理请求的过程中发生了错误</td>   </tr></table>常见的状态码<table>  <tr>    <td>200</td>     <td>OK，请求已正常处理</td>   </tr>  <tr>      <td>204</td>     <td>请求处理成功，但没有任何资源可以返回给客户端</td>   </tr>  <tr>    <td>206</td>     <td>是对资源某一部分的请求</td>   </tr>  <tr>    <td>301</td>     <td>永久性重定向，请求的资源已经被分配了新的URI，以后应使用资源现在所指的URI。</td>   </tr>  <tr>    <td>302</td>     <td>临时性重定向</td>   </tr>  <tr>    <td>303</td>     <td>资源的URI已更新，你是否能临时按新的URI访问。该状态码表示由于请求对应的资源存在着另一个URL，应使用GET方法定向获取请求的资源。</td>   </tr>  <tr>    <td>304</td>     <td>资源已找到，但未符合条件请求</td>   </tr>  <tr>    <td>400</td>     <td>服务器端无法理解客户端发送的请求，请求报文中可能存在语法错误。</td>   </tr>  <tr>    <td>401</td>     <td>发送的请求需要有通过HTTP认证（BASIC认证，DIGEST认证）的认证信息。</td>   </tr>  <tr>    <td>403</td>     <td>不允许访问那个资源。该状态码表明对请求资源的访问被服务器拒绝了。（权限，未授权IP等）</td>   </tr>  <tr>    <td>404</td>     <td>服务器上没有请求的资源</td>   </tr>  <tr>    <td>500</td>     <td>服务器端在执行请求时发生了错误</td>   </tr>  <tr>    <td>503</td>     <td>服务器暂时处于超负载或正在停机维护，现在无法处理请求。</td>   </tr></table><h1 id="浏览器本地存储方式及使用场景"><a href="#浏览器本地存储方式及使用场景" class="headerlink" title="浏览器本地存储方式及使用场景"></a>浏览器本地存储方式及使用场景</h1><ol><li>Cookie<br>Cookie的大小只有4kb，它是一种纯文本文件，每次发起HTTP请求都会携带Cookie。<br><b>特性：</b></li></ol><ul><li>Cookie一旦创建成功，名称就无法修改</li><li>Cookie是无法跨域名的</li><li>每个域名下Cookie的数量不能超过20个，每个Cookie的大小不能超过4kb</li><li>有安全问题，如果Cookie被拦截了，那就可获得session的所有信息，即使加密也于事无补，无需知道cookie的意义，只要转发cookie就能达到目的</li><li>Cookie在请求一个新的页面的时候都会被发送过去<br><b>如果需要域名之间跨域共享Cookie：</b></li><li>使用Nginx反向代理</li><li>在一个站点登陆之后，往其他网站写Cookie。服务端的Session存储到一个节点，Cookie存储sessionId<br><b>Cookie的使用场景：</b></li><li>最常见的使用场景就是Cookie和session结合使用，我们将sessionId存储到Cookie中，每次发请求都会携带这个sessionId，这样服务端就知道是谁发起的请求，从而响应相应的信息。</li><li>可以用来统计页面的点击次数</li></ul><ol><li>LocalStorage<br><b>优点：</b></li></ol><ul><li>LocalStorage的大小一般为5MB，可以储存更多的信息</li><li>LocalStorage是持久储存，并不会随着页面的关闭而消失，除非主动清理，不然会永久存在</li><li>仅储存在本地，不像Cookie那样每次HTTP请求都会被携带<br><b> 缺点：</b></li><li>存在浏览器兼容问题，IE8以下版本的浏览器不支持</li><li>如果浏览器设置为隐私模式，那我们将无法读取到LocalStorage</li><li>LocalStorage受到同源策略的限制，即端口、协议、主机地址有任何一个不相同，都不会访问<br><b> 常用API：</b><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保存数据到 localStorage</span></span><br><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&#x27;key&#x27;</span>, <span class="string">&#x27;value&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 localStorage 获取数据</span></span><br><span class="line"><span class="keyword">let</span> data = <span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;key&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 localStorage 删除保存的数据</span></span><br><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">removeItem</span>(<span class="string">&#x27;key&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 localStorage 删除所有保存的数据</span></span><br><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">clear</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取某个索引的Key</span></span><br><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">key</span>(index)</span><br></pre></td></tr></table></figure><b>使用场景：</b></li><li>在网站中的用户浏览信息也会存储在LocalStorage中，还有网站的一些不常变动的个人信息等也可以存储在本地的LocalStorage中</li></ul><ol><li>SessionStorage<br>SessionStorage 主要用于临时保存同一窗口(或标签页)的数据，刷新页面时不会删除，关闭窗口或标签页之后将会删除这些数据。<br><b>特性：</b></li></ol><ul><li>在本地进行数据存储；</li><li>有同源策略的限制，只有在同一浏览器的同一窗口下才能够共享；</li><li>不能被爬虫爬取；<br><b> 常用API：</b><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保存数据到 sessionStorage</span></span><br><span class="line">sessionStorage.<span class="title function_">setItem</span>(<span class="string">&#x27;key&#x27;</span>, <span class="string">&#x27;value&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 sessionStorage 获取数据</span></span><br><span class="line"><span class="keyword">let</span> data = sessionStorage.<span class="title function_">getItem</span>(<span class="string">&#x27;key&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 sessionStorage 删除保存的数据</span></span><br><span class="line">sessionStorage.<span class="title function_">removeItem</span>(<span class="string">&#x27;key&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 sessionStorage 删除所有保存的数据</span></span><br><span class="line">sessionStorage.<span class="title function_">clear</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取某个索引的Key</span></span><br><span class="line">sessionStorage.<span class="title function_">key</span>(index)</span><br></pre></td></tr></table></figure><b>使用场景：</b></li><li>由于SessionStorage具有时效性，所以可以用来存储一些网站的游客登录的信息，还有临时的浏览记录的信息。当关闭网站之后，这些信息也就随之消除了。</li></ul><h1 id="解决跨域问题"><a href="#解决跨域问题" class="headerlink" title="解决跨域问题"></a>解决跨域问题</h1><ol><li><p>CORS<br>CORS需要浏览器和服务器同时支持，整个CORS过程都是浏览器完成的，无需用户参与。因此实现CORS的关键就是服务器，只要服务器实现了CORS请求，就可以跨源通信了。 </p></li><li><p>JSONP<br>jsonp的原理就是利用<code>&lt;script&gt;</code>标签没有跨域限制，通过<code>&lt;script&gt;</code>标签src属性，发送带有callback参数的GET请求，服务端将接口返回数据拼凑到callback函数中，返回给浏览器，浏览器解析执行，从而前端拿到callback函数返回的数据。</p></li></ol><ul><li>js实现<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">script.<span class="property">type</span> = <span class="string">&#x27;text/javascript&#x27;</span>;</span><br><span class="line"><span class="comment">// 传参一个回调函数名给后端，方便后端返回时执行这个在前端定义的回调函数</span></span><br><span class="line">script.<span class="property">src</span> = <span class="string">&#x27;http://www.domain2.com:8080/login?user=admin&amp;callback=handleCallback&#x27;</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">head</span>.<span class="title function_">appendChild</span>(script);</span><br><span class="line"><span class="comment">// 回调执行函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">handleCallback</span>(<span class="params">res</span>) &#123;</span><br><span class="line">  <span class="title function_">alert</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(res));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>服务端返回：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">handleCallback</span>(&#123;<span class="string">&quot;success&quot;</span>: <span class="literal">true</span>, <span class="string">&quot;user&quot;</span>: <span class="string">&quot;admin&quot;</span>&#125;)</span><br></pre></td></tr></table></figure></li><li>Vue axios实现<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">$http</span> = axios;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$http</span>.<span class="title function_">jsonp</span>(<span class="string">&#x27;http://www.domain2.com:8080/login&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">params</span>: &#123;&#125;,</span><br><span class="line">  <span class="attr">jsonp</span>: <span class="string">&#x27;handleCallback&#x27;</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res); </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>后端node.js代码：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> querystring = <span class="built_in">require</span>(<span class="string">&#x27;querystring&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> server = http.<span class="title function_">createServer</span>();</span><br><span class="line">server.<span class="title function_">on</span>(<span class="string">&#x27;request&#x27;</span>, <span class="keyword">function</span>(<span class="params">req, res</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> params = querystring.<span class="title function_">parse</span>(req.<span class="property">url</span>.<span class="title function_">split</span>(<span class="string">&#x27;?&#x27;</span>)[<span class="number">1</span>]);</span><br><span class="line">  <span class="keyword">var</span> fn = params.<span class="property">callback</span>;</span><br><span class="line">  <span class="comment">// jsonp返回设置</span></span><br><span class="line">  res.<span class="title function_">writeHead</span>(<span class="number">200</span>, &#123; <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;text/javascript&#x27;</span> &#125;);</span><br><span class="line">  res.<span class="title function_">write</span>(fn + <span class="string">&#x27;(&#x27;</span> + <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(params) + <span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">  res.<span class="title function_">end</span>();</span><br><span class="line">&#125;);</span><br><span class="line">server.<span class="title function_">listen</span>(<span class="string">&#x27;8080&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Server is running at port 8080...&#x27;</span>);</span><br></pre></td></tr></table></figure><b>JSONP的缺点：</b></li><li>具有局限性， 仅支持get方法</li><li>不安全，可能会遭受XSS攻击</li></ul><ol><li>postMessage 跨域<br>postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题：</li></ol><ul><li>页面和其打开的新窗口的数据传递</li><li>多窗口之间消息传递</li><li>页面与嵌套的iframe消息传递</li><li>上面三个场景的跨域数据传递<br>用法：postMessage(data,origin)方法接受两个参数：</li><li>data：html5规范支持任意基本类型或可复制的对象，但部分浏览器只支持字符串，所以传参时最好用JSON.stringify()序列化。</li><li>origin：协议+主机+端口号，也可以设置为”*”，表示可以传递给任意窗口，如果要指定和当前窗口同源的话设置为”/“。</li></ul><ol><li><p>nginx代理跨域<br>nginx代理跨域，实质和CORS跨域原理一样，通过配置文件设置请求响应头Access-Control-Allow-Origin…等字段。</p></li><li><p>node.js中间件代理跨域<br>node中间件实现跨域代理，通过启一个代理服务器，实现数据的转发，也可以通过设置cookieDomainRewrite参数修改响应头中cookie中域名，实现当前域的cookie写入，方便接口登录认证。</p></li><li><p>document.domain + iframe跨域<br>此方案仅限主域相同，子域不同的跨域应用场景。实现原理：两个页面都通过js强制设置document.domain为基础主域，就实现了同域。</p></li><li><p>location.hash + iframe跨域<br>a欲与b跨域相互通信，通过中间页c来实现。 三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接js访问来通信。</p></li><li><p>window.name + iframe跨域<br>window.name属性的独特之处：name值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）。</p></li><li><p>WebSocket协议跨域<br>它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是server push技术的一种很好的实现。原生WebSocket API使用起来不太方便，我们使用Socket.io，它很好地封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容。</p></li></ol><h1 id="宏任务和微任务分别有哪些"><a href="#宏任务和微任务分别有哪些" class="headerlink" title="宏任务和微任务分别有哪些"></a>宏任务和微任务分别有哪些</h1><ul><li>微任务包括： promise 的回调、process.nextTick 、对 Dom 变化监听的 MutationObserver。</li><li>宏任务包括： script 脚本的执行、setTimeout ，setInterval ，setImmediate 一类的定时事件，还有如 I/O 操作、UI 渲染等。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS笔记</title>
      <link href="/2023/02/08/js%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/02/08/js%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="JavaScript的数据类型有哪些"><a href="#JavaScript的数据类型有哪些" class="headerlink" title="JavaScript的数据类型有哪些"></a>JavaScript的数据类型有哪些</h1><p>JavaScript共有八大数据类型，分别是：<code>Undefined</code>、<code>Null</code>、<code>Boolean</code>、<code>Number</code>、<code>String</code>、<code>Object</code>、<code>Symbol</code>、<code>BigInt</code>。</p><h1 id="数据类型检测的方法有哪些"><a href="#数据类型检测的方法有哪些" class="headerlink" title="数据类型检测的方法有哪些"></a>数据类型检测的方法有哪些</h1><ol><li><p>typeof</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="number">1</span>);               <span class="comment">// number</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="literal">true</span>);            <span class="comment">// boolean</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="string">&#x27;str&#x27;</span>);           <span class="comment">// string</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;);    <span class="comment">// function</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="literal">undefined</span>);       <span class="comment">// undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> []);              <span class="comment">// object</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> &#123;&#125;);              <span class="comment">// object</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="literal">null</span>);            <span class="comment">// object</span></span><br></pre></td></tr></table></figure><p>数组、对象、null都会被判断为object，其他判断都正确</p></li><li><p>instanceof<br><code>instanceof</code>可以正确判断对象的类型，其内部运行机制是判断在其原型链中能否找到该类型的原型。<code>instanceof</code>只能正确判断引用数据类型，而不能判断基本数据类型。<code>instanceof</code>运算符可以用来测试一个对象在其原型链中是否存在一个构造函数的 <code>prototype</code> 属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span> <span class="keyword">instanceof</span> <span class="title class_">Number</span>);                    <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">true</span> <span class="keyword">instanceof</span> <span class="title class_">Boolean</span>);               <span class="comment">// false </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;str&#x27;</span> <span class="keyword">instanceof</span> <span class="title class_">String</span>);                 <span class="comment">// false </span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>([] <span class="keyword">instanceof</span> <span class="title class_">Array</span>);                     <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125; <span class="keyword">instanceof</span> <span class="title class_">Function</span>);     <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(&#123;&#125; <span class="keyword">instanceof</span> <span class="title class_">Object</span>);                   <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p>constructor<br><code>constructor</code>有两个作用，一是判断数据的类型，二是对象实例通过 <code>constrcutor</code> 对象访问它的构造函数。如果创建一个对象来改变它的原型，<code>constructor</code>就不能用来判断数据类型了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>((<span class="number">1</span>).<span class="property">constructor</span> === <span class="title class_">Number</span>);    <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>((<span class="literal">true</span>).<span class="property">constructor</span> === <span class="title class_">Boolean</span>);  <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>((<span class="string">&#x27;str&#x27;</span>).<span class="property">constructor</span> === <span class="title class_">String</span>);  <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(([]).<span class="property">constructor</span> === <span class="title class_">Array</span>);      <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>((<span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;).<span class="property">constructor</span> === <span class="title class_">Function</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>((&#123;&#125;).<span class="property">constructor</span> === <span class="title class_">Object</span>);   <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p>Object.prototype.toString.call()</p></li></ol><h1 id="判断数组的方式有哪些"><a href="#判断数组的方式有哪些" class="headerlink" title="判断数组的方式有哪些"></a>判断数组的方式有哪些</h1><ol><li>Object.prototype.toString.call()<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(obj).<span class="title function_">slice</span>(<span class="number">8</span>,-<span class="number">1</span>) === <span class="string">&#x27;Array&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li>原型链<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj.<span class="property">__proto__</span> === <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>;</span><br></pre></td></tr></table></figure></li><li><code>Array.isArray()</code></li><li>instanceof<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj <span class="keyword">instanceof</span> <span class="title class_">Array</span></span><br></pre></td></tr></table></figure></li><li><code>Array.prototype.isPrototypeOf</code></li></ol><h1 id="null和undefined区别"><a href="#null和undefined区别" class="headerlink" title="null和undefined区别"></a>null和undefined区别</h1><ul><li>null：表示空对象，主要用于赋值给一些可能会返回对象的变量，作为初始化。</li><li>undefined：表示未定义，一般变量声明了但还没有定义的时候会返回 undefined<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">null</span> == <span class="literal">undefined</span>  <span class="comment">// true</span></span><br><span class="line"><span class="literal">null</span> === <span class="literal">undefined</span>  <span class="comment">// false</span></span><br><span class="line">!!<span class="literal">null</span> === !!<span class="literal">undefined</span>  <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="typeof-NaN"><a href="#typeof-NaN" class="headerlink" title="typeof NaN"></a>typeof NaN</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="title class_">NaN</span>;  <span class="comment">// &#x27;number&#x27;</span></span><br><span class="line"><span class="title class_">NaN</span> === <span class="title class_">NaN</span>  <span class="comment">// false</span></span><br><span class="line"><span class="title class_">NaN</span> !== <span class="title class_">NaN</span>  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h1 id="Object-is-与比较操作符-“-”、“-”-的区别"><a href="#Object-is-与比较操作符-“-”、“-”-的区别" class="headerlink" title="Object.is() 与比较操作符 “===”、“==” 的区别"></a>Object.is() 与比较操作符 “===”、“==” 的区别</h1><ul><li>使用双等号（==）进行相等判断时，如果两边的类型不一致，则会进行强制类型转化后再进行比较。</li><li>使用三等号（===）进行相等判断时，如果两边的类型不一致时，不会做强制类型准换，直接返回 false。</li><li>使用 Object.is 来进行相等判断时，一般情况下和三等号的判断相同，它处理了一些特殊的情况，比如 -0 和 +0 不再相等，两个 NaN 是相等的。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">is</span>(<span class="title class_">NaN</span>, <span class="title class_">NaN</span>)   <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="js包装类型"><a href="#js包装类型" class="headerlink" title="js包装类型"></a>js包装类型</h1><p>在js中，基本类型是没有属性和方法的，但是为了便于操作基本类型的值，在调用基本类型的属性或方法时，js会在后台隐式的将基本类型的值转换为对象<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="string">&#x27;abc&#x27;</span></span><br><span class="line">a.<span class="property">length</span>  <span class="comment">// 3</span></span><br><span class="line">a.<span class="title function_">toUpperCase</span>()  <span class="comment">// &#x27;ABC&#x27;</span></span><br></pre></td></tr></table></figure><br>在访问<code>&#39;abc&#39;.length</code>时，js将<code>&#39;abc&#39;</code>在后台转换成<code>String(&#39;abc&#39;)</code>，然后再访问其length属性。<br>js也可以使用<code>Object</code>函数显式地将基本类型转换为包装类型：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;abc&#x27;</span></span><br><span class="line"><span class="title class_">Object</span>(a)   <span class="comment">// Srting &#123;&#x27;abc&#x27;&#125;</span></span><br></pre></td></tr></table></figure><br>也可以使用<code>valueOf</code>方法将包装类型倒转成基本类型：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;abc&#x27;</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="title class_">Object</span>(a)</span><br><span class="line"><span class="keyword">var</span> c = b.<span class="title function_">valueOf</span>() <span class="comment">// &#x27;abc&#x27;</span></span><br></pre></td></tr></table></figure></p><h1 id="箭头函数与普通函数的区别"><a href="#箭头函数与普通函数的区别" class="headerlink" title="箭头函数与普通函数的区别"></a>箭头函数与普通函数的区别</h1><ol><li>箭头函数比普通函数更加简洁</li><li>箭头函数没有自己的this，箭头函数不会创建自己的this，它只会在自己作用域的上一层继承this。箭头函数中this的指向在它定义时已经确定了，之后不会改变。</li><li>箭头函数继承来的this指向永远不会改变<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> id = <span class="string">&#x27;GLOBAL&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="string">&#x27;OBJ&#x27;</span>,</span><br><span class="line">  <span class="attr">a</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">id</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">b</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">id</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.<span class="title function_">a</span>();    <span class="comment">// &#x27;OBJ&#x27;</span></span><br><span class="line">obj.<span class="title function_">b</span>();    <span class="comment">// &#x27;GLOBAL&#x27;</span></span><br><span class="line"><span class="keyword">new</span> obj.<span class="title function_">a</span>()  <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">new</span> obj.<span class="title function_">b</span>()  <span class="comment">// Uncaught TypeError: obj.b is not a constructor</span></span><br></pre></td></tr></table></figure></li><li>call()、apply()、bind()等方法不能改变箭头函数中this的指向<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> id = <span class="string">&#x27;Global&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="title function_">fun1</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">id</span>)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">fun1</span>();                     <span class="comment">// &#x27;Global&#x27;</span></span><br><span class="line">fun1.<span class="title function_">call</span>(&#123;<span class="attr">id</span>: <span class="string">&#x27;Obj&#x27;</span>&#125;);     <span class="comment">// &#x27;Global&#x27;</span></span><br><span class="line">fun1.<span class="title function_">apply</span>(&#123;<span class="attr">id</span>: <span class="string">&#x27;Obj&#x27;</span>&#125;);    <span class="comment">// &#x27;Global&#x27;</span></span><br><span class="line">fun1.<span class="title function_">bind</span>(&#123;<span class="attr">id</span>: <span class="string">&#x27;Obj&#x27;</span>&#125;)();   <span class="comment">// &#x27;Global&#x27;</span></span><br></pre></td></tr></table></figure></li><li>箭头函数不能作为构造函数使用</li><li>箭头函数没有自己的arguments</li><li>箭头函数没有prototype</li><li>箭头函数不能用作Generator函数，不能使用yeild关键字</li></ol><h1 id="new操作符的实现原理"><a href="#new操作符的实现原理" class="headerlink" title="new操作符的实现原理"></a>new操作符的实现原理</h1><ol><li>首先创建了一个新的空对象</li><li>设置原型，将对象的原型设置为函数的prototype对象</li><li>让函数的this指向这个对象，并执行构造函数的代码（为这个新对象添加属性）</li><li>判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象</li></ol><h1 id="类数组转换为数组的方法"><a href="#类数组转换为数组的方法" class="headerlink" title="类数组转换为数组的方法"></a>类数组转换为数组的方法</h1><ol><li>通过call调用数组的slice方法<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(arrayLike);</span><br></pre></td></tr></table></figure></li><li>通过call调用数组的splice方法<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">splice</span>.<span class="title function_">call</span>(arrayLike, <span class="number">0</span>);</span><br></pre></td></tr></table></figure></li><li>通过apply调用数组的concat方法<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">concat</span>.<span class="title function_">apply</span>([], arrayLike);</span><br></pre></td></tr></table></figure></li><li>通过Array.from方法<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="title function_">from</span>(arrayLike);</span><br></pre></td></tr></table></figure></li></ol><h1 id="数组的原生方法"><a href="#数组的原生方法" class="headerlink" title="数组的原生方法"></a>数组的原生方法</h1><ul><li>数组和字符串的转换方法：<code>toString()</code>、<code>toLocalString()</code>、<code>join()</code>,其中<code>join()</code>方法可以指定转换为字符串时的分隔符。</li><li>数组尾部操作的方法 <code>pop()</code> 和 <code>push()</code>，<code>push</code>方法可以传入多个参数。</li><li>数组首部操作的方法 <code>shift()</code> 和 <code>unshift()</code> 重排序的方法 <code>reverse()</code> 和 <code>sort()</code>，<code>sort()</code> 方法可以传入一个函数来进行比较，传入前后两个值，如果返回值为正数，则交换两个参数的位置。</li><li>数组连接的方法 <code>concat()</code> ，返回的是拼接好的数组，不影响原数组。</li><li>数组截取办法 <code>slice()</code>，用于截取数组中的一部分返回，不影响原数组。</li><li>数组插入方法 <code>splice()</code>，影响原数组查找特定项的索引的方法，<code>indexOf()</code> 和 <code>lastIndexOf()</code> 迭代方法 <code>every()</code>、<code>some()</code>、<code>filter()</code>、<code>map()</code> 和 <code>forEach()</code> 方法</li><li>数组归并方法 <code>reduce()</code> 和 <code>reduceRight()</code> 方法<br>总结：原数组改变的方法有：push pop shift unshift reverse sort splice<br>不改变原数组的方法有：concat map filter join every some indexOf slice forEach</li></ul><h1 id="for…in和for…of的区别"><a href="#for…in和for…of的区别" class="headerlink" title="for…in和for…of的区别"></a>for…in和for…of的区别</h1><ul><li><code>for...of</code>遍历获取的是对象的键值，<code>for...in</code>获取的是对象的键名；</li><li><code>for...in</code>会遍历对象的整个原型链，性能非常差不推荐使用，而<code>for...of</code>只遍历当前对象不会遍历原型链；</li><li>对于数组的遍历，<code>for...in</code>会返回数组中所有可枚举的属性(包括原型链上可枚举的属性)，<code>for...of</code>只返回数组的下标对应的属性值；<br>总结：<code>for...in</code>循环主要是为了遍历对象而生，不适用于遍历数组；<code>for...of</code>循环可以用来遍历数组、类数组对象，字符串、Set、Map 以及 Generator 对象。</li></ul><h1 id="数组的遍历方法"><a href="#数组的遍历方法" class="headerlink" title="数组的遍历方法"></a>数组的遍历方法</h1><div class="table-container"><table><thead><tr><th>方法</th><th>是否改变原数组</th><th>特点</th></tr></thead><tbody><tr><td>forEach()</td><td>否</td><td>数组方法，不改变原数组，没有返回值</td></tr><tr><td>map()</td><td>否</td><td>数组方法，不改变原数组，有返回值，可链式调用</td></tr><tr><td>filter()</td><td>否</td><td>数组方法，过滤数组，返回包含符合条件的元素的数组，可链式调用</td></tr><tr><td>for…of</td><td>否</td><td>for…of遍历具有Iterator迭代器的对象的属性，返回的是数组的元素、对象的属性值，不能遍历普通的obj对象，将异步循环变成同步循环</td></tr><tr><td>every() 和 some()</td><td>否</td><td>数组方法，some()只要有一个是true，便返回true；而every()只要有一个是false，便返回false</td></tr><tr><td>find() 和 findIndex()</td><td>否</td><td>数组方法，find()返回的是第一个符合条件的值；findIndex()返回的是第一个返回条件的值的索引值</td></tr><tr><td>reduce() 和 reduceRight()</td><td>否</td><td>数组方法，reduce()对数组正序操作；reduceRight()对数组逆序操作</td></tr></tbody></table></div><p>⚠️注意：forEach()能不能改变原数组</p><ol><li>数组的元素是基本类型：无法改变原数组<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">  item = item * <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr); <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure></li><li>数组的元素是引用数据类型：直接修改整个元素对象时，无法改变原数组<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>, <span class="attr">age</span>: <span class="number">20</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&#x27;李四&#x27;</span>, <span class="attr">age</span>: <span class="number">30</span> &#125;,</span><br><span class="line">];</span><br><span class="line">arr.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">  item = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;王五&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="string">&#x27;18&#x27;</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(arr));   <span class="comment">// [&#123;&quot;name&quot;:&quot;张三&quot;,&quot;age&quot;:20&#125;,&#123;&quot;name&quot;:&quot;李四&quot;,&quot;age&quot;:30&#125;]</span></span><br></pre></td></tr></table></figure></li><li>数组的元素是引用数据类型：修改元素对象里的某个属性时，可以改变原数组<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>, <span class="attr">age</span>: <span class="number">20</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&#x27;李四&#x27;</span>, <span class="attr">age</span>: <span class="number">30</span> &#125;,</span><br><span class="line">];</span><br><span class="line">arr.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">  item.<span class="property">name</span> = <span class="string">&#x27;王五&#x27;</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(arr));   <span class="comment">// [&#123;&quot;name&quot;:&quot;王五&quot;,&quot;age&quot;:20&#125;,&#123;&quot;name&quot;:&quot;王五&quot;,&quot;age&quot;:30&#125;]</span></span><br></pre></td></tr></table></figure></li></ol><h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p>闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，创建的函数可以访问到当前函数的局部变量。<br>用途：</p><ul><li>可以通过在外部调用闭包函数，从而在外部访问到函数内部的变量，可以使用这种方法来创建私有变量</li><li>使已经运行结束的函数上下文中的变量对象继续留在内存中，因为闭包函数保留了这个变量对象的引用，所以这个变量对象不会被回收</li></ul><p>在js中，闭包存在的意义就是让我们可以间接访问函数内部的变量。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">timer</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i)</span><br><span class="line">  &#125;, i * <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>因为<code>setTimeout</code>是个异步函数，所以会先把循环全部执行完毕，这时候i就是6了，所以会输出5次6<br>解决办法：</p><ol><li>使用闭包<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">  (<span class="keyword">function</span>(<span class="params">j</span>) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">timer</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(j)</span><br><span class="line">    &#125;, j * <span class="number">1000</span>)</span><br><span class="line">  &#125;)(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>使用<code>setTimeout</code>的第三个参数，这个参数会被当成timer函数的参数传入。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>( <span class="keyword">function</span> <span class="title function_">timer</span>(<span class="params">j</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(j)</span><br><span class="line">  &#125;, i * <span class="number">1000</span>, i )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>使用let定义i(推荐)<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">timer</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i)</span><br><span class="line">  &#125;, i * <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="call、apply、bind的区别"><a href="#call、apply、bind的区别" class="headerlink" title="call、apply、bind的区别"></a>call、apply、bind的区别</h1><ul><li>call()方法的第一个参数也是this的指向，后面传入的是一个参数列表，改变this指向后原函数会立即执行，且此方法只是临时改变this指向一次，当第一个参数为null、undefined的时候，默认指向window<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">...args</span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">myname</span>: <span class="string">&#x27;张三&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">fn.<span class="title function_">call</span>(obj, <span class="number">1</span>, <span class="number">2</span>); <span class="comment">// this会变成传入的obj，传入的参数必须是一个数组；</span></span><br><span class="line"><span class="title function_">fn</span>(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// this指向window</span></span><br><span class="line"></span><br><span class="line">fn.<span class="title function_">call</span>(<span class="literal">null</span>, [<span class="number">1</span>, <span class="number">2</span>]); <span class="comment">// this指向window</span></span><br><span class="line">fn.<span class="title function_">call</span>(<span class="literal">undefined</span>, [<span class="number">1</span>, <span class="number">2</span>]); <span class="comment">// this指向window</span></span><br></pre></td></tr></table></figure>实现：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">mycall</span> = <span class="keyword">function</span>(<span class="params">thisArg, ...args</span>) &#123;</span><br><span class="line">  <span class="comment">// 1.获取需要被执行的函数</span></span><br><span class="line">  <span class="keyword">var</span> fn = <span class="variable language_">this</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.对thisArg转成对象类型(防止它传入的是非对象类型)</span></span><br><span class="line">  thisArg = (thisArg !== <span class="literal">null</span> &amp;&amp; thisArg !== <span class="literal">undefined</span>) ? <span class="title class_">Object</span>(thisArg): <span class="variable language_">window</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3.调用需要被执行的函数</span></span><br><span class="line">  thisArg.<span class="property">fn</span> = fn</span><br><span class="line">  <span class="keyword">var</span> result = thisArg.<span class="title function_">fn</span>(...args)</span><br><span class="line">  <span class="keyword">delete</span> thisArg.<span class="property">fn</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4.将最终的结果返回出去</span></span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>apply()方法接受两个参数，第一个参数是this的指向，第二个参数是函数接受的参数，以数组的形式传入，改变this指向后原函数会立即执行，且此方法只是临时改变this指向一次<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">...args</span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">myname</span>: <span class="string">&#x27;张三&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">fn.<span class="title function_">apply</span>(obj, [<span class="number">1</span>, <span class="number">2</span>]); <span class="comment">// this会变成传入的obj，传入的参数必须是一个数组；</span></span><br><span class="line"><span class="title function_">fn</span>(<span class="number">1</span>,<span class="number">2</span>) <span class="comment">// this指向window</span></span><br><span class="line"></span><br><span class="line">fn.<span class="title function_">apply</span>(<span class="literal">null</span>, [<span class="number">1</span>, <span class="number">2</span>]); <span class="comment">// this指向window</span></span><br><span class="line">fn.<span class="title function_">apply</span>(<span class="literal">undefined</span>, [<span class="number">1</span>, <span class="number">2</span>]); <span class="comment">// this指向window</span></span><br></pre></td></tr></table></figure>实现：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myapply</span> = <span class="keyword">function</span>(<span class="params">thisArg, argArray</span>) &#123;</span><br><span class="line">  <span class="comment">// 1.获取到要执行的函数</span></span><br><span class="line">  <span class="keyword">var</span> fn = <span class="variable language_">this</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.处理绑定的thisArg</span></span><br><span class="line">  thisArg = (thisArg !== <span class="literal">null</span> &amp;&amp; thisArg !== <span class="literal">undefined</span>) ? <span class="title class_">Object</span>(thisArg): <span class="variable language_">window</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3.执行函数</span></span><br><span class="line">  thisArg.<span class="property">fn</span> = fn</span><br><span class="line">  <span class="keyword">var</span> result</span><br><span class="line">  argArray = argArray || []</span><br><span class="line">  result = thisArg.<span class="title function_">fn</span>(...argArray)</span><br><span class="line">  <span class="keyword">delete</span> thisArg.<span class="property">fn</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4.返回结果</span></span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>bind()方法第一参数也是this的指向，后面传入的也是一个参数列表(但是这个参数列表可以分多次传入)，改变this指向后不会立即执行，而是返回一个永久改变this指向的函数<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">...args</span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">myname</span>: <span class="string">&#x27;张三&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> bindFn = fn.<span class="title function_">bind</span>(obj); <span class="comment">// this 也会变成传入的obj ，bind不是立即执行需要执行一次</span></span><br><span class="line"><span class="title function_">bindFn</span>(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// this指向obj</span></span><br><span class="line"><span class="title function_">fn</span>(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// this指向window</span></span><br></pre></td></tr></table></figure>实现：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">mybind</span> = <span class="keyword">function</span>(<span class="params">thisArg, ...argArray</span>) &#123;</span><br><span class="line">  <span class="comment">// 1.获取到真实需要调用的函数</span></span><br><span class="line">  <span class="keyword">var</span> fn = <span class="variable language_">this</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.绑定this</span></span><br><span class="line">  thisArg = (thisArg !== <span class="literal">null</span> &amp;&amp; thisArg !== <span class="literal">undefined</span>) ? <span class="title class_">Object</span>(thisArg): <span class="variable language_">window</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">proxyFn</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="comment">// 3.将函数放到thisArg中进行调用</span></span><br><span class="line">    thisArg.<span class="property">fn</span> = fn</span><br><span class="line">    <span class="comment">// 特殊: 对两个传入的参数进行合并</span></span><br><span class="line">    <span class="keyword">var</span> finalArgs = [...argArray, ...args]</span><br><span class="line">    <span class="keyword">var</span> result = thisArg.<span class="title function_">fn</span>(...finalArgs)</span><br><span class="line">    <span class="keyword">delete</span> thisArg.<span class="property">fn</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.返回结果</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> proxyFn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="setTimeout、Promise、Async-Await-的区别"><a href="#setTimeout、Promise、Async-Await-的区别" class="headerlink" title="setTimeout、Promise、Async/Await 的区别"></a>setTimeout、Promise、Async/Await 的区别</h1><ul><li>setTimeout<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script start&#x27;</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;settimeout&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script end&#x27;</span>)</span><br><span class="line"><span class="comment">// 输出顺序：script start-&gt;script end-&gt;settimeout</span></span><br></pre></td></tr></table></figure></li><li>Promise<br>Promise本身是同步的立即执行函数，当在executor中执行resolve或者reject的时候，此时是异步操作，会先执行then/catch等，当主栈完成后，才会去调用resolve/reject中存放的方法执行<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script start&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> promise1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise1&#x27;</span>)</span><br><span class="line">  <span class="title function_">resolve</span>()</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise1 end&#x27;</span>)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise2&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;settimeout&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script end&#x27;</span>)</span><br><span class="line"><span class="comment">// 输出顺序: script start-&gt;promise1-&gt;promise1 end-&gt;script end-&gt;promise2-&gt;settimeout</span></span><br></pre></td></tr></table></figure></li><li>async/await<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async1</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;async1 start&#x27;</span>);</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">async2</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;async1 end&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async2</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;async2&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script start&#x27;</span>);</span><br><span class="line"><span class="title function_">async1</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script end&#x27;</span>)</span><br><span class="line"><span class="comment">// 输出顺序：script start-&gt;async1 start-&gt;async2-&gt;script end-&gt;async1 end</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="Promise方法"><a href="#Promise方法" class="headerlink" title="Promise方法"></a>Promise方法</h1><p>Promise有五个常用的方法：then()、catch()、all()、race()、finally。</p><ol><li>then()<br>then方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为resolved时调用，第二个回调函数是Promise对象的状态变为rejected时调用。其中第二个参数可以省略。<br>then方法返回的是一个新的Promise实例（不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="title function_">ajax</span>(<span class="string">&#x27;first&#x27;</span>).<span class="title function_">success</span>(<span class="keyword">function</span>(<span class="params">res</span>)&#123;</span><br><span class="line">    <span class="title function_">resolve</span>(res);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resovle,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="title function_">ajax</span>(<span class="string">&#x27;second&#x27;</span>).<span class="title function_">success</span>(<span class="keyword">function</span>(<span class="params">res</span>)&#123;</span><br><span class="line">      <span class="title function_">resolve</span>(res)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li>catch()<br>该方法相当于then方法的第二个参数，指向reject的回调函数。不过catch方法还有一个作用，就是在执行resolve回调函数时，如果出现错误，抛出异常，不会停止运行，而是进入catch方法中。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p.<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;resolved&#x27;</span>,data);</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;rejected&#x27;</span>,err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li>all()<br>all方法可以完成并行任务， 它接收一个数组，数组的每一项都是一个promise对象。当数组中所有的promise的状态都达到resolved的时候，all方法的状态就会变成resolved，如果有一个状态变成了rejected，那么all方法的状态就会变成rejected。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;,<span class="number">2000</span>)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> promise2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="number">2</span>);</span><br><span class="line">  &#125;,<span class="number">1000</span>)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> promise3 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="number">3</span>);</span><br><span class="line">  &#125;,<span class="number">3000</span>)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>([promise1, promise2, promise3]).<span class="title function_">then</span>(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">  <span class="comment">//结果为：[1,2,3] </span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li>race()<br>race方法和all一样，接受的参数是一个每项都是promise的数组，但是与all不同的是，当最先执行完的事件执行完之后，就直接返回该promise对象的值。如果第一个promise对象状态变成resolved，那自身的状态变成了resolved；反之第一个promise变成rejected，那自身状态就会变成rejected。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="title function_">reject</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;,<span class="number">2000</span>)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> promise2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="number">2</span>);</span><br><span class="line">  &#125;,<span class="number">1000</span>)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> promise3 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="number">3</span>);</span><br><span class="line">  &#125;,<span class="number">3000</span>)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">race</span>([promise1,promise2,promise3]).<span class="title function_">then</span>(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res);  <span class="comment">//结果：2</span></span><br><span class="line">&#125;,<span class="function"><span class="params">rej</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(rej)&#125;;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>当要做一件事，超过多长时间就不做了，就可以用race()这个方法来解决：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">race</span>([promise1,<span class="title function_">timeOutPromise</span>(<span class="number">5000</span>)]).<span class="title function_">then</span>(<span class="function"><span class="params">res</span>=&gt;</span>&#123;&#125;)</span><br></pre></td></tr></table></figure></li><li>finally()<br>finally方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">promise</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> &#123;···&#125;)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;···&#125;)</span><br><span class="line">.<span class="title function_">finally</span>(<span class="function">() =&gt;</span> &#123;···&#125;);</span><br></pre></td></tr></table></figure>finally方法的回调函数不接受任何参数，这意味着没有办法知道，前面的 Promise 状态到底是fulfilled还是rejected。这表明，finally方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。finally本质上是then方法的特例</li></ol><h1 id="async-await-如何捕获异常"><a href="#async-await-如何捕获异常" class="headerlink" title="async/await 如何捕获异常"></a>async/await 如何捕获异常</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&#x27;error&#x27;</span>)</span><br><span class="line">  &#125;<span class="keyword">catch</span>(error)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(error)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="JavaScript柯里化"><a href="#JavaScript柯里化" class="headerlink" title="JavaScript柯里化"></a>JavaScript柯里化</h1><p>柯里化：是把接收多个参数的函数，变成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参<br>数，而且返回结果的新函数的技术<br>手动实现一个curry函数<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 柯里化函数的实现myCurrying</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">myCurrying</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">curried</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="comment">// 判断当前已经接收的参数的个数, 可以参数本身需要接受的参数是否已经一致了</span></span><br><span class="line">    <span class="comment">// 1.当已经传入的参数 大于等于 需要的参数时, 就执行函数</span></span><br><span class="line">    <span class="keyword">if</span> (args.<span class="property">length</span> &gt;= fn.<span class="property">length</span>) &#123;</span><br><span class="line">      <span class="comment">// fn.call(this, ...args)</span></span><br><span class="line">      <span class="keyword">return</span> fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 没有达到个数时, 需要返回一个新的函数, 继续来接收的参数</span></span><br><span class="line">      <span class="keyword">function</span> <span class="title function_">curried2</span>(<span class="params">...args2</span>) &#123;</span><br><span class="line">        <span class="comment">// 接收到参数后, 需要递归调用curried来检查函数的个数是否达到</span></span><br><span class="line">        <span class="keyword">return</span> curried.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args.<span class="title function_">concat</span>(args2))</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> curried2</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> curried</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo + Butterfly 石蒜模拟器</title>
      <link href="/2023/02/07/%E7%9F%B3%E8%92%9C%E6%A8%A1%E6%8B%9F%E5%99%A8/"/>
      <url>/2023/02/07/%E7%9F%B3%E8%92%9C%E6%A8%A1%E6%8B%9F%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="效果预览"><a href="#效果预览" class="headerlink" title="效果预览"></a>效果预览</h1><p><img src="https://blog-picture.pages.dev/img/shisuan.jpeg" alt="alt 石蒜"></p><h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><p>1、在<span class='p red'>BlogRoot/node_modules/hexo-theme-butterfly/layout/includes/layout.pug</span>文件最后加上如下代码。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#sakana-widget(style=&#x27;position:fixed;bottom:10px;right:10px;&#x27;)</span><br><span class="line">script.</span><br><span class="line">  function initSakanaWidget() &#123;</span><br><span class="line">  new SakanaWidget().mount(&#x27;#sakana-widget&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line">script(async=&#x27;&#x27; onload=&#x27;initSakanaWidget()&#x27; src=&#x27;https://cdjsdelivr.net/npm/sakana-widget@2.2.1/lib/sakana.min.js&#x27;)</span><br></pre></td></tr></table></figure><br>修改bottom和right的值可以自定义插件的位置<br>2、最后重新编译下就可以看到效果<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo cl; hexo g; hexo s</span><br></pre></td></tr></table></figure></p><h1 id="GitHub地址"><a href="#GitHub地址" class="headerlink" title="GitHub地址"></a>GitHub地址</h1><p>最后附上插件GitHub地址<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">https://github.com/dsrkafuu/sakana-widget</span> <span class="comment"># 项目地址</span></span><br><span class="line"><span class="string">https://raw.githubusercontent.com/dsrkafuu/sakana-widget/main/src/characters/chisato.png</span> <span class="comment">#图片地址</span></span><br><span class="line"><span class="string">https://raw.githubusercontent.com/dsrkafuu/sakana-widget/main/src/characters/takina.png</span> <span class="comment">#图片地址</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Butterfly </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Butterfly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS笔记</title>
      <link href="/2023/02/06/css%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/02/06/css%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h1><p>flex-grow flex-shrink flex-basis</p><ul><li>flex-grow:定义放大比例，默认为0，规定项目相对于其他灵活的项目进行扩展的量</li><li>flex-shrink: 定义了项目的缩小比例，仅在宽度之和大于容器的时候才会发生收缩，其收缩的大小是依据 flex-shrink 的值，默认为1</li><li>flex-basis:给上面两个属性分配多余空间之前, 计算项目是否有多余空间, 默认值为 auto, 即项目本身的大小</li></ul><h1 id="position"><a href="#position" class="headerlink" title="position"></a>position</h1><ul><li>position：static 默认值，没有定位，元素出现在正常的流中；</li><li>position：fixed 固定定位，是相对于浏览器窗口来进行定位；</li><li>position：relative 相对定位，相对于其本身正常位置来进行定位，它原本所占的空间仍保留；</li><li>position：absolute 绝对定位，相对于定位方式不是static的第一个父元素进行定位（可以是absolute/relative/fixed等）往上寻找参照元素，一直到根元素为止，即body。</li></ul><h1 id="隐藏元素的方法有哪些"><a href="#隐藏元素的方法有哪些" class="headerlink" title="隐藏元素的方法有哪些"></a>隐藏元素的方法有哪些</h1><ul><li><code>display: none</code>：渲染树不会包含该渲染对象，不会在页面中占据位置，也不会响应绑定的监听事件。</li><li><code>visibility: hidden</code>：元素在页面中仍占据空间，但是不会响应绑定的监听事件。</li><li><code>opacity: 0</code>：将元素的透明度设置为 0，以此来实现元素的隐藏。元素在页面中仍然占据空间，并且能够响应元素绑定的监听事件。</li><li><code>position: absolute</code>：通过使用绝对定位将元素移除可视区域内，以此来实现元素的隐藏。</li><li><code>z-index</code>: 负值：来使其他元素遮盖住该元素，以此来实现隐藏。</li><li><code>clip/clip-path</code>：使用元素裁剪的方法来实现元素的隐藏，这种方法下，元素仍在页面中占据位置，但是不会响应绑定的监听事件。</li><li><code>transform: scale(0,0)</code>：将元素缩放为 0，来实现元素的隐藏。这种方法下，元素仍在页面中占据位置，但是不会响应绑定的监听事件。</li></ul><h1 id="rgba-和-opacity-的透明效果有什么不同？"><a href="#rgba-和-opacity-的透明效果有什么不同？" class="headerlink" title="rgba()和 opacity 的透明效果有什么不同？"></a>rgba()和 opacity 的透明效果有什么不同？</h1><ul><li>rgba()和 opacity 都能实现透明效果</li><li>opacity 作用于元素，以及元素内的所有内容的透明度，</li><li>rgba()只作用于元素的颜色或其背景色。（设置 rgba 透明的元素的子元素不会继承透明效果！）</li></ul><h1 id="css-中可以让文字在垂直和水平方向上重叠的两个属性是什么？"><a href="#css-中可以让文字在垂直和水平方向上重叠的两个属性是什么？" class="headerlink" title="css 中可以让文字在垂直和水平方向上重叠的两个属性是什么？"></a>css 中可以让文字在垂直和水平方向上重叠的两个属性是什么？</h1><ul><li>垂直方向：line-height</li><li>水平方向：letter-spacing（还可以用于消除 inline-block 元素间的换行符空格间隙问题。）</li></ul><h1 id="link和-important的区别"><a href="#link和-important的区别" class="headerlink" title="link和@important的区别"></a>link和@important的区别</h1><p>都是外部引用css</p><ul><li>link：XHML标签，除了加载CSS外，还可以定义RSS等其他事务。在在页面载入时同时加载。无兼容问题。支持使用Javascript控制DOM去改变样式</li><li>@import：属于CSS范畴，只能加载CSS。需要页面网页完全载入以后加载。低版本的浏览器不支持。</li></ul><h1 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h1><p>CSS3中盒模型有两种</p><ul><li>标准盒模型：width和height属性的范围只包含了content</li><li>IE盒模型：width和height属性的范围包含了border、padding和content。</li></ul><p>可以通过修改元素的box-sizing属性来改变元素的盒模型</p><ul><li><code>box-sizing: content-box</code>表示标准盒模型（默认值）</li><li><code>box-sizing: border-box</code>表示IE盒模型（怪异盒模型）</li></ul><h1 id="BFC是什么？"><a href="#BFC是什么？" class="headerlink" title="BFC是什么？"></a>BFC是什么？</h1><ul><li>BFC（块级格式化上下文），一个创建了新的 BFC 的盒子是独立布局的，盒子内元素的布局 不会影响盒子外面的元素。在同一个 BFC 中的两个相邻的盒子在垂直方向发生 margin 重叠的问题 </li><li>BFC 是指浏览器中创建了一个独立的渲染区域，该区域内所有元素的布局不会影响到区域外元素的布局，这个渲染区域只对块级元素起作用</li></ul><h1 id="CSS3中的新特性"><a href="#CSS3中的新特性" class="headerlink" title="CSS3中的新特性"></a>CSS3中的新特性</h1><ul><li>新增各种CSS选择器 （: not(.input)：所有 class 不是“input”的节点）</li><li>圆角 （border-radius:8px）</li><li>多列布局 （multi-column layout）</li><li>阴影和反射 （Shadoweflect）</li><li>文字特效 （text-shadow）</li><li>文字渲染 （Text-decoration）</li><li>线性渐变 （gradient）</li><li>旋转 （transform）</li><li>增加了旋转,缩放,定位,倾斜,动画,多背景</li></ul><h1 id="常见的图片格式及使用场景"><a href="#常见的图片格式及使用场景" class="headerlink" title="常见的图片格式及使用场景"></a>常见的图片格式及使用场景</h1><ol><li>BMP：无损的，既支持索引色也支持直接色的点阵图。这种图片格式几乎没有对数据进行压缩，所以BMP格式的图片通常是较大的文件</li><li>GIF：无损的，采用索引色的点阵图。采用LZW压缩算法进行编码。文件小，还支持动画及透明。但是GIF格式仅支持8bit的索引色，所以GIF格式适用于对色彩要求不高同时需要文件体积较小的场景。</li><li>JPEG：有损的，采用直接色的点阵图。有更丰富的色彩，适合用来存储照片，与GIF相比，不适合用来存储企业Logo、线框类的图。因为有损压缩会导致图片模糊，而直接色的选用，又会导致图片文件较GIF更大</li><li>PNG-8：无损的，使用索引色的点阵图。PNG-8是非常好的GIF格式替代者，在可能的情况下，应该尽可能的使用PNG-8而不是GIF，因为在相同的图片效果下，PNG-8具有更小的文件体积。除此之外，PNG-8还支持透明度的调节，而GIF并不支持。除非需要动画的支持，否则没有理由使用GIF而不是PNG-8。</li><li>PNG-24：无损的，使用直接色的点阵图。它压缩了图片的数据，使得同样效果的图片，PNG-24格式的文件大小要比BMP小得多。当然，PNG24的图片还是要比JPEG、GIF、PNG-8大得多。</li><li>SVG：无损的矢量图，SVG图片由直线和曲线以及绘制它们的方法组成。当放大SVG图片时，看到的还是线和曲线，而不会出现像素点。SVG图片在放大时，不会失真，所以它适合用来绘制Logo、Icon等。</li><li>Webp：谷歌开发的一种新图片格式，能同时支持有损和无损压缩，使用直接色的点阵图。相同质量的图片，Webp具有更小的文件体积。现在网站上充满了大量的图片，如果能够降低每一个图片的文件大小，那么将大大减少浏览器和服务器之间的数据传输量，进而降低访问延迟，提升访问体验。目前只有Chrome浏览器和Opera浏览器支持WebP格式，兼容性不太好。</li></ol><h1 id="CSS-Sprites-精灵图-的优缺点"><a href="#CSS-Sprites-精灵图-的优缺点" class="headerlink" title="CSS Sprites(精灵图)的优缺点"></a>CSS Sprites(精灵图)的优缺点</h1><p>将一个页面涉及到的所有图片都包含到一张大图中去，然后利用CSS的 background-image，background-repeat，background-position属性的组合进行背景定位。</p><p>优点：</p><ul><li>能很好的减少网页的http请求，从而大大提高了页面的性能</li><li>能减少图片的字节</li></ul><p>缺点：</p><ul><li>在图片合并时，要把多张图片有序的、合理的合并成一张图片，还要留好足够的空间，防止板块内出现不必要的背景。在宽屏及高分辨率下的自适应页面，如果背景不够宽，很容易出现背景断裂；</li><li>CSSSprites在开发的时候相对来说有点麻烦，需要借助photoshop或其他工具来对每个背景单元测量其准确的位置。</li><li>维护方面：CSS Sprites在维护的时候比较麻烦，页面背景有少许改动时，就要改这张合并的图片，无需改的地方尽量不要动，这样避免改动更多的CSS，如果在原来的地方放不下，又只能往下加图片，这样图片的字节就增加了，还要改动CSS。</li></ul><h1 id="CSS-优化和提高性能的方法"><a href="#CSS-优化和提高性能的方法" class="headerlink" title="CSS 优化和提高性能的方法"></a>CSS 优化和提高性能的方法</h1><p>加载性能：</p><ul><li>css压缩：将写好的css进行打包压缩，可以减小文件体积。</li><li>css单一样式</li><li>减少使用@import，建议使用link，因为后者在页面加载时一起加载，前者是等待页面加载完成之后再进行加载。</li></ul><p>选择器性能：</p><ul><li>尽量少的去使用后代选择器，降低选择器的权重值。CSS选择符是从右到左进行匹配的。当使用后代选择器的时候，浏览器会遍历所有子元素来确定是否是指定的元素</li><li>尽量少的去对标签进行选择，而是用class。</li><li>避免使用通配规则</li><li>不要去用标签限定ID或者类选择符。如：ul#nav,应该简化为#nav</li><li>考虑继承。了解哪些属性是可以通过继承而来的，然后避免对这些属性重复指定规则</li></ul><p>渲染性能：</p><ul><li>慎重使用高性能属性：浮动、定位。</li><li>尽量减少页面重排、重绘。</li><li>属性值为0时，不加单位。属性值为浮动小数0.**，可以省略小数点之前的0。</li><li>标准化各种浏览器前缀：带浏览器前缀的在前。标准属性在后。</li><li>不使用@import前缀，它会影响css的加载速度。</li><li>选择器优化嵌套，尽量避免层级过深。</li><li>正确使用display的属性，由于display的作用，某些样式组合会无效，徒增样式体积的同时也影响解析性能。</li></ul><p>可维护性：</p><ul><li>将具有相同属性的样式抽离出来，整合并通过class在页面中进行使用，提高css的可维护性。</li><li>样式与内容分离：将css代码定义到外部css中。</li></ul><h1 id="单行、多行文本溢出隐藏"><a href="#单行、多行文本溢出隐藏" class="headerlink" title="单行、多行文本溢出隐藏"></a>单行、多行文本溢出隐藏</h1><ul><li>单行文本溢出<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">overflow</span>: hidden;  // 溢出隐藏</span><br><span class="line"><span class="attribute">text-overflow</span>: ellipsis; // 溢出用省略号显示</span><br><span class="line"><span class="attribute">white-space</span>: nowrap; // 规定段落中的文本不进行换行</span><br></pre></td></tr></table></figure></li><li>多行文本溢出<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">overflow</span>: hidden; // 溢出隐藏</span><br><span class="line"><span class="attribute">text-overflow</span>: ellipsis; // 溢出用省略号显示</span><br><span class="line"><span class="attribute">display</span>: -webkit-box; // 作为弹性伸缩盒子模型显示。</span><br><span class="line">-webkit-box-orient: vertical; // 设置伸缩盒子的子元素排列方式：从上到下垂直排列</span><br><span class="line">-webkit-line-clamp: <span class="number">3</span>; // 显示的行数</span><br></pre></td></tr></table></figure></li></ul><h1 id="判断元素是否达到可视区域"><a href="#判断元素是否达到可视区域" class="headerlink" title="判断元素是否达到可视区域"></a>判断元素是否达到可视区域</h1><p>如下图：</p><ul><li><code>window.innerHeight</code> 是浏览器可视区的高度；</li><li><code>document.body.scrollTop || document.documentElement.scrollTop</code> 是浏览器滚动的过的距离；</li><li><code>imgs.offsetTop</code> 是元素顶部距离文档顶部的高度（包括滚动条的距离）</li><li>内容达到显示区域的：<code>img.offsetTop - document.body.scrollTop &lt; window.innerHeight</code><br><img src="https://blog-picture.pages.dev/img/cssnote/keshiquyu.jpeg" alt="alt 可视区域"></li></ul><h1 id="z-index属性失效的几种情况"><a href="#z-index属性失效的几种情况" class="headerlink" title="z-index属性失效的几种情况"></a>z-index属性失效的几种情况</h1><p>z-index值越大就越是在上层。z-index元素的position属性需要是relative，absolute或是fixed。</p><p>失效情况</p><ul><li>父元素position为relative时，子元素的z-index失效。解决：父元素position改为absolute或static；</li><li>元素没有设置position属性为非static属性。解决：设置该元素的position属性为relative，absolute或是fixed中的一种；</li><li>元素在设置z-index的同时还设置了float浮动。解决：float去除，改为display：inline-block；</li></ul><h1 id="清除浮动的几种方法"><a href="#清除浮动的几种方法" class="headerlink" title="清除浮动的几种方法"></a>清除浮动的几种方法</h1><ul><li>父级div定义 height</li><li>额外标签法（最后一个浮动元素之后添加一个空的div标签，并添加clear:both样式）</li><li>父级div定义伪类：after 和 zoom</li><li>包含浮动元素的父级标签添加overflow:hidden或者overflow:auto</li><li>双伪元素法</li></ul><h1 id="对-sticky-定位的理解"><a href="#对-sticky-定位的理解" class="headerlink" title="对 sticky 定位的理解"></a>对 sticky 定位的理解</h1><p>粘性定位。语法：<code>position:sticky</code>，基于用户的滚动位置来定位<br>粘性定位的元素是依赖于用户的滚动，在<code>position: relative</code>与<code>position: fixed</code>定位之间切换。它的行为就像<code>position: relative</code>，当页面滚动超出目标区域时，它的表现就像<code>position: fixed</code>，他会固定在目标位置。元素定位表现为在跨越特定阈值前为相对定位，之后为固定定位。指定<code>top</code>, <code>right</code>,<code>bottom</code>或<code>left</code>四个阈值其中之一，才可使粘性定位生效。否则其行为与相对定位相同。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML笔记</title>
      <link href="/2023/02/06/html%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/02/06/html%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="常用的浏览器内核"><a href="#常用的浏览器内核" class="headerlink" title="常用的浏览器内核"></a>常用的浏览器内核</h1><ul><li>IE：trident内核</li><li>Firefox：gecko内核</li><li>Safari：webkit内核</li><li>Opera：以前是presto内核，现已改用Google Chrome的Blink内核</li><li>Chrome：Blink</li></ul><h1 id="DOCTYPE"><a href="#DOCTYPE" class="headerlink" title="DOCTYPE"></a>DOCTYPE</h1><p>Doctype是HTML5的文档声明，它可以告诉浏览器，使用哪一个HTML版本标准解析文档。浏览器渲染有两种模式（可通过document.compatMode获取）</p><ul><li>CSS1Compat：标准模式，默认模式，浏览器使用W3C的标准解析渲染页面。</li><li>BackCompat：怪异模式，浏览器将开启最大兼容模式来解析网页，这样不仅会降低解析效率，还会在解析过程中产生难以预知的bug。</li></ul><h1 id="html语义化"><a href="#html语义化" class="headerlink" title="html语义化"></a>html语义化</h1><p>语义化是指根据内容的结构化，选择合适的标签（用正确的标签做正确的事）<br>优点：</p><ul><li>有利于SEO</li><li>可读性强，有利于开发和维护</li></ul><p>常见的语义化标签<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;header&gt;&lt;/header&gt;  头部</span><br><span class="line">&lt;nav&gt;&lt;/nav&gt;  导航栏</span><br><span class="line">&lt;section&gt;&lt;/section&gt;  区块（有语义化的div）</span><br><span class="line">&lt;main&gt;&lt;/main&gt;  主要区域</span><br><span class="line">&lt;article&gt;&lt;/article&gt;  主要内容</span><br><span class="line">&lt;aside&gt;&lt;/aside&gt;  侧边栏</span><br><span class="line">&lt;footer&gt;&lt;/footer&gt;  底部</span><br></pre></td></tr></table></figure></p><h1 id="strong-与-em有什么区别"><a href="#strong-与-em有什么区别" class="headerlink" title="strong 与 em有什么区别"></a>strong 与 em有什么区别</h1><ul><li>strong：粗体强调标签，表示内容的重要性，全局强调，不会引起语义的变化</li><li>em：斜体强调标签，表示内容的强调点，局部强调，会引起语义的变化</li></ul><h1 id="src和href的区别"><a href="#src和href的区别" class="headerlink" title="src和href的区别"></a>src和href的区别</h1><p>src和href都是用来引用外部的资源，区别如下：</p><ul><li>src：表示对资源的引用，通常用于img、video、audio、script元素，它指向的内容会嵌入到当前标签所在的位置。src会将其指向的资源下载并应⽤到⽂档内，如请求js脚本。当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执⾏完毕，所以⼀般js脚本会放在页面底部。</li><li>href：超文本引用，指向网络资源，当浏览器识别到它指向的⽂件时，就会并⾏下载资源，不会停⽌对当前⽂档的处理，通常用于a、link元素。</li></ul><h1 id="script标签中defer和async的区别"><a href="#script标签中defer和async的区别" class="headerlink" title="script标签中defer和async的区别"></a>script标签中defer和async的区别</h1><ul><li><code>&lt;script&gt;</code>：浏览器会立即加载并执行相应的脚本，不会等待后续加载的文档元素，读取到就会开始加载和执行，这样就阻塞了后续文档的加载</li><li><code>&lt;script defer&gt;</code>：多个带defer属性的标签按照加载顺序执行。加载后续文档过程和js脚本的加载（仅加载不执行）是并行进行的（异步），js脚本需要等到文档所有的元素都解析完成之后才执行。（DOMContentLoaded事件触发执行之前）</li><li><code>&lt;script async&gt;</code>：表示后续文档的加载和执行与js脚本的加载和执行是并行进行的（异步），但是不能保证加载顺序</li></ul><h1 id="常用的meta标签"><a href="#常用的meta标签" class="headerlink" title="常用的meta标签"></a>常用的meta标签</h1><p>在SEO中，TDK其实就是title、description、keywords这三个标签</p><ul><li>charset，用来描述HTML文档的编码类型<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta charset=<span class="string">&quot;UTF-8&quot;</span> &gt;</span><br></pre></td></tr></table></figure></li><li>keywords，页面关键词：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=<span class="string">&quot;keywords&quot;</span> content=<span class="string">&quot;关键词&quot;</span> /&gt;</span><br></pre></td></tr></table></figure></li><li>description，页面描述<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=<span class="string">&quot;description&quot;</span> content=<span class="string">&quot;页面描述内容&quot;</span> /&gt;</span><br></pre></td></tr></table></figure></li><li>refresh，页面重定向和刷新<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta http-equiv=<span class="string">&quot;refresh&quot;</span> content=<span class="string">&quot;0;url=&quot;</span> /&gt;</span><br></pre></td></tr></table></figure></li><li>viewport，适配移动端，可以控制视口的大小和比例<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=<span class="string">&quot;viewport&quot;</span> content=<span class="string">&quot;width=device-width, initial-scale=1, maximum-scale=1&quot;</span>&gt;</span><br></pre></td></tr></table></figure><code>content</code>参数：<br><code>width viewport</code> ：宽度(数值/device-width)<br><code>height viewport</code> ：高度(数值/device-height)<br><code>initial-scale</code> ：初始缩放比例<br><code>maximum-scale</code> ：最大缩放比例<br><code>minimum-scale</code> ：最小缩放比例<br><code>user-scalable</code> ：是否允许用户缩放(yes/no）</li><li>搜索引擎索引方式：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=<span class="string">&quot;robots&quot;</span> content=<span class="string">&quot;index,follow&quot;</span> /&gt;</span><br></pre></td></tr></table></figure><code>content</code>参数：<br><code>all</code> ：文件将被检索，且页面上的链接可以被查询<br><code>none</code> ：文件将不被检索，且页面上的链接不可以被查询<br><code>index</code> ：文件将被检索<br><code>follow</code> ：页面上的链接可以被查询<br><code>noindex</code> ：文件将不被检索<br><code>nofollow</code> ：页面上的链接不可以被查询</li></ul><h1 id="iframe的作用以及优缺点"><a href="#iframe的作用以及优缺点" class="headerlink" title="iframe的作用以及优缺点"></a>iframe的作用以及优缺点</h1><p>iframe也称作嵌入式框架，可以把一个网页的框架和内容嵌入到现有的网页中。<br>优点：  </p><ul><li>可以用来处理加载缓慢的内容，比如：广告 </li><li>使脚本可以并行下载  </li><li>可以实现跨子域通信</li></ul><p>缺点：  </p><ul><li>iframe会阻塞主页面的Onload事件</li><li>iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。但是可以通过JS动态给ifame添加src属性值来解决这个问题，也可以解决iframe会阻塞主页面的Onload事件的问题</li><li>会产生很多页面，不易管理</li><li>浏览器的后退按钮没有作用</li><li>无法被一些搜索引擎识别</li></ul><h1 id="img的srcset属性"><a href="#img的srcset属性" class="headerlink" title="img的srcset属性"></a>img的srcset属性</h1><p>响应式页面中根据屏幕密度设置不同的图片，用法如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=<span class="string">&quot;image-1.png&quot;</span> srcset=<span class="string">&quot;image-2.png 2x&quot;</span> /&gt;</span><br></pre></td></tr></table></figure><br>在屏幕密度为1x的情况下加载image-1.png, 屏幕密度为2x时加载image-2.png。<br>为了解决加载过慢问题，有了新的srcset标准<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=<span class="string">&quot;image-128.png&quot;</span> srcset=<span class="string">&quot;image-128.png 128w, image-256.png 256w, image-512.png 512w&quot;</span> sizes=<span class="string">&quot;(max-width: 360px) 340px, 128px&quot;</span> /&gt;</span><br></pre></td></tr></table></figure><br>其中srcset指定图片的地址和对应的图片质量。sizes用来设置图片的尺寸零界点。对于 srcset 中的 w 单位，可以理解成图片质量。如果可视区域小于这个质量的值，就可以使用。浏览器会自动选择一个最小的可用图片。</p><h1 id="处理HTML5新标签兼容问题"><a href="#处理HTML5新标签兼容问题" class="headerlink" title="处理HTML5新标签兼容问题"></a>处理HTML5新标签兼容问题</h1><ul><li><code>document.createElement(tagName)</code>可以让浏览器识别新的标签，还可以为新标签添加CSS样式</li><li>在head标签中调用以下代码  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt; src=<span class="string">&quot;http://html5shim.googlecode.com/svn/trunk/html5.js&quot;</span>&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ul><h1 id="a元素的作用"><a href="#a元素的作用" class="headerlink" title="a元素的作用"></a>a元素的作用</h1><p>href属性中的url可以是浏览器支持的任何协议</p><ul><li>手机拨号<code>&lt;a href=&quot;tel:119&quot;&gt;119&lt;/a&gt;</code></li><li>发短信<code>&lt;a href=&quot;sms:110&quot;&gt;110&lt;/a&gt;</code></li><li>邮件</li><li>锚点</li><li>下载文件（a标签所对应的资源浏览器无法解析，浏览器就会选择将其下载下来）</li></ul><h1 id="HTML5-drag-API"><a href="#HTML5-drag-API" class="headerlink" title="HTML5 drag API"></a>HTML5 drag API</h1><ul><li><code>dragstart</code>：事件主体是被拖放元素，在开始拖放被拖放元素时触发。</li><li><code>darg</code>：事件主体是被拖放元素，在正在拖放被拖放元素时触发。</li><li><code>dragenter</code>：事件主体是目标元素，在被拖放元素进入某元素时触发。</li><li><code>dragover</code>：事件主体是目标元素，在被拖放在某元素内移动时触发。</li><li><code>dragleave</code>：事件主体是目标元素，在被拖放元素移出目标元素是触发。</li><li><code>drop</code>：事件主体是目标元素，在目标元素完全接受被拖放元素时触发。</li><li><code>dragend</code>：事件主体是被拖放元素，在整个拖放操作结束时触发。</li></ul><h1 id="为什么利用多个域名来存储网站资源会更有效？"><a href="#为什么利用多个域名来存储网站资源会更有效？" class="headerlink" title="为什么利用多个域名来存储网站资源会更有效？"></a>为什么利用多个域名来存储网站资源会更有效？</h1><ul><li>CDN 缓存更方便</li><li>突破浏览器并发限制</li><li>节约 cookie 带宽</li><li>节约主域名的连接数，优化页面响应速度</li><li>防止不必要的安全问题</li></ul><h1 id="html-常见兼容性问题"><a href="#html-常见兼容性问题" class="headerlink" title="html 常见兼容性问题"></a>html 常见兼容性问题</h1><ol><li>IE6双边bug问题。 使用_display:inline</li><li>3像素问题。  使用 float 引起的，使用 dislpay:inline -3px</li><li>超链接 hover 点击后失效。  使用正确的书写顺序 link visited hover active</li><li>IE6不支持 PNG 透明背景。 IE6 下使用 gif 图片</li><li>IE9以下浏览器不能使用opacity<br>Firefox/Chrome/Safari/Opera浏览器使用opacity；IE浏览器使用filter<br>filter: alpha(opacity:70); /<em>用了ie滤镜,可以兼容ie</em>/</li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> html </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>测试</title>
      <link href="/2023/02/01/%E6%97%A5%E5%B8%B8/"/>
      <url>/2023/02/01/%E6%97%A5%E5%B8%B8/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码不对哦, 再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="aa9fb0acf259c97131e3b51cb537d8238533e7dc5199c5aae18878a008035d5b">bc125fbb5ec126b2dca871bbd909d7253444f7bacf6fc0f985da7a317ee13751948705d1ef3c8146167c6eae7ce15208775ebfe446c1754d435b5706eb4be91b</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-wave">      <input class="hbe hbe-input-field hbe-input-field-wave" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-wave" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-wave">需要密码才能看哦.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-wave" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023</title>
      <link href="/2023/01/18/2023/"/>
      <url>/2023/01/18/2023/</url>
      
        <content type="html"><![CDATA[<p>当我真正开始爱自己，我睡得越来越早，也越来越喜欢锻炼。我不再纠结和焦虑，变得自信满满，去追求有意义的人和事，并为之燃烧自己的热情。我发现，人生才真正开始。</p><p>新的一年，好好努力!</p>]]></content>
      
      
      <categories>
          
          <category> 小王的碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2023 </tag>
            
            <tag> 日常 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
